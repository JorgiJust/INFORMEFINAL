\documentclass[12pt,a4]{article}
\usepackage[demo]{graphicx} % Opción demo para placeholders
\usepackage{graphics}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsbsy}
\usepackage{color}
\usepackage{listings}
\usepackage{lipsum}
\usepackage{url}
\usepackage{enumerate}
\usepackage{float}
\usepackage{hyperref}
\usepackage{authblk}
\lstset{
language=C++,
basicstyle=\footnotesize,
numbers=left,
numberstyle=\footnotesize,
stepnumber=1,
numbersep=10pt, 
backgroundcolor=\color{white},
showspaces=false,
showstringspaces=false,
showtabs=false,
tabsize=2,
captionpos=b, 
breaklines=true,
breakatwhitespace=false,
escapeinside={\%*}{*)}
}
\renewcommand{\lstlistingname}{Programa}
\renewcommand{\figurename}{Figura}
\renewcommand{\abstractname}{Resumen}
\renewcommand{\tablename}{Tabla}
\renewcommand{\refname}{Referencias}

\begin{document}

\begin{flushright}
{\bf Reporte:}\\
{\bf M\'etodos Num\'ericos}\\
{\bf O.Burgoa} \\
{\bf UPB}\\
{\bf 04/diciembre/2025}\\
{\bf Autor:}\\
{\bf J. Saenz}\\
\end{flushright}

\begin{abstract}
Se presentan 7 programas en lenguaje C++ que implementan m\'etodos num\'ericos fundamentales. El Programa 1 implementa el m\'etodo de Newton-Raphson para encontrar ra\'ices de ecuaciones. El Programa 2 resuelve sistemas de ecuaciones no lineales. El Programa 3 calcula la serie de Fourier de una funci\'on en un intervalo. Los programas 4, 5, 6 y 7 implementan c\'alculo de derivadas parciales y totales, ecuaciones diferenciales ordinarias de primer y segundo orden, y sistemas de ecuaciones diferenciales respectivamente.
\end{abstract}

\section{1. Metodo de Newton-Raphson}

El método de Newton-Raphson es un algoritmo iterativo para encontrar aproximaciones de las raíces de una función real. Dada una función $f(x)$ y su derivada $f'(x)$, el método calcula sucesivamente mejores aproximaciones mediante la fórmula:

\[
x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
\]

\subsection{Código}

Se implementó un programa en C++ que calcula raíces de funciones utilizando el método de Newton-Raphson. El código incluye funciones para evaluar la función objetivo y su derivada, un ciclo iterativo para aplicar la fórmula de Newton, y criterios de parada basados en tolerancia y número máximo de iteraciones.

\textbf{Nota:} Se utilizó 70\% de IA para la generación de este código.

\subsection{Gráficos generados por el Programa 1}

La Figura 1 muestra la convergencia del método de Newton-Raphson hacia la raíz de la función $f(x) = x^3 - 2x - 5$.

\begin{center}
  \includegraphics[height=7cm]{newton_grafico.png}\\
  Figura 1: Método de Newton-Raphson para $f(x) = x^3 - 2x - 5$.
\end{center}

\subsection{Análisis de resultados}
La Figura 1 ilustra la función $f(x) = x^3 - 2x - 5$ (línea azul), las iteraciones del método (puntos rojos) y la raíz encontrada (punto verde). El método converge rápidamente a la raíz en aproximadamente 5 iteraciones, demostrando su eficiencia para funciones con derivadas no nulas cerca de la raíz.

\newpage

\section{2. Sistema de dos ecuaciones no lineales}

El método de Newton para sistemas de ecuaciones no lineales extiende el método de Newton-Raphson a múltiples dimensiones. Para un sistema de dos ecuaciones:

\[
\begin{cases}
f_1(x,y) = 0 \\
f_2(x,y) = 0
\end{cases}
\]

Se utiliza la matriz Jacobiana para actualizar las aproximaciones.

\subsection{Código}

Se desarrolló un programa en C++ que resuelve sistemas de dos ecuaciones no lineales utilizando el método de Newton multidimensional. El código calcula la matriz Jacobiana numéricamente, resuelve el sistema lineal en cada iteración, y actualiza las aproximaciones hasta alcanzar la convergencia.

\textbf{Nota:} Se utilizó 70\% de IA para la generación de este código.

\subsection{Gráficos generados por el Programa 2}

La Figura 2 muestra las curvas correspondientes a las ecuaciones y el punto de intersección encontrado.

\begin{center}
  \includegraphics[height=7cm]{sistema_grafico.png}\\
  Figura 2: Sistema de ecuaciones no lineales: $x^2 + y^2 = 4$ y $e^x + y = 1$.
\end{center}

\subsection{Análisis de resultados}
La Figura 2 presenta el círculo $x^2 + y^2 = 4$ (línea azul), la curva exponencial $e^x + y = 1$ (línea rosa), la trayectoria del método Newton (línea verde) y la solución encontrada (punto negro). El método encuentra la intersección entre ambas curvas en aproximadamente 6 iteraciones.

\newpage

\section{3. Serie de Fourier de una función en un intervalo [0:2L] (ejemplo con grafica)}

La serie de Fourier de una función $f(x)$ definida en el intervalo $[0, 2L]$ está dada por:

\[
f(x) \sim \frac{a_0}{2} + \sum_{n=1}^{\infty} \left[a_n \cos\left(\frac{n\pi x}{L}\right) + b_n \sin\left(\frac{n\pi x}{L}\right)\right]
\]

donde los coeficientes son:

\[
a_n = \frac{1}{L} \int_0^{2L} f(x) \cos\left(\frac{n\pi x}{L}\right) dx
\]
\[
b_n = \frac{1}{L} \int_0^{2L} f(x) \sin\left(\frac{n\pi x}{L}\right) dx
\]

\subsection{Código}

Se implementó un programa en C++ que calcula los coeficientes de Fourier de una función definida en el intervalo $[0, 2L]$. El código utiliza integración numérica para calcular los coeficientes $a_n$ y $b_n$, y reconstruye la función original mediante la suma parcial de la serie de Fourier.

\textbf{Nota:} Se utilizó 70\% de IA para la generación de este código.

\subsection{Gráficos generados por el Programa 3}

La Figura 3 muestra la función original y su aproximación por series de Fourier.

\begin{center}
  \includegraphics[height=7cm]{fourier_grafico.png}\\
  Figura 3: Aproximación por series de Fourier de una función triangular.
\end{center}

\subsection{Análisis de resultados}
La Figura 3 presenta la función triangular original (línea azul sólida) y su aproximación de Fourier con N términos (línea roja discontinua). La serie de Fourier converge a la función original a medida que aumentamos el número de términos, aunque se observa el fenómeno de Gibbs cerca de las discontinuidades.

\newpage

\section{4. Derivadas totales y parciales:}

Este programa calcula derivadas parciales y totales de funciones de una y dos variables. Las derivadas se calculan numéricamente usando diferencias finitas.

\subsection{4.1 a) D[f(x),x]}

Primera derivada de una función univariada $f(x)$. Se implementó el cálculo usando diferencias finitas centrales:

\[
f'(x) \approx \frac{f(x+h) - f(x-h)}{2h}
\]

\textbf{Nota:} Se utilizó 70\% de IA para la generación de este código.

\subsection{4.2 b) D[f(x),\{x,2\}]}

Segunda derivada de una función univariada $f(x)$. Se implementó el cálculo usando diferencias finitas centrales:

\[
f''(x) \approx \frac{f(x+h) - 2f(x) + f(x-h)}{h^2}
\]

\textbf{Nota:} Se utilizó 70\% de IA para la generación de este código.

\subsection{4.3 c) D[f(x,y),x]}

Derivada parcial de una función bivariada $f(x,y)$ respecto a $x$. Se implementó el cálculo usando diferencias finitas centrales:

\[
\frac{\partial f}{\partial x} \approx \frac{f(x+h,y) - f(x-h,y)}{2h}
\]

\textbf{Nota:} Se utilizó 70\% de IA para la generación de este código.

\subsection{4.4 d) D[f(x,y),y]}

Derivada parcial de una función bivariada $f(x,y)$ respecto a $y$. Se implementó el cálculo usando diferencias finitas centrales:

\[
\frac{\partial f}{\partial y} \approx \frac{f(x,y+h) - f(x,y-h)}{2h}
\]

\textbf{Nota:} Se utilizó 70\% de IA para la generación de este código.

\subsection{4.5 e) D[f(x,y),\{x,2\}]}

Segunda derivada parcial de una función bivariada $f(x,y)$ respecto a $x$. Se implementó el cálculo usando diferencias finitas centrales:

\[
\frac{\partial^2 f}{\partial x^2} \approx \frac{f(x+h,y) - 2f(x,y) + f(x-h,y)}{h^2}
\]

\textbf{Nota:} Se utilizó 70\% de IA para la generación de este código.

\subsection{4.6 f) D[f(x,y),\{y,2\}]}

Segunda derivada parcial de una función bivariada $f(x,y)$ respecto a $y$. Se implementó el cálculo usando diferencias finitas centrales:

\[
\frac{\partial^2 f}{\partial y^2} \approx \frac{f(x,y+h) - 2f(x,y) + f(x,y-h)}{h^2}
\]

\textbf{Nota:} Se utilizó 70\% de IA para la generación de este código.

\subsection{4.7 g) D[f(x,y),\{x,y\}]}

Derivada cruzada mixta de una función bivariada $f(x,y)$. Se implementó el cálculo usando diferencias finitas centrales:

\[
\frac{\partial^2 f}{\partial x \partial y} \approx \frac{f(x+h,y+h) - f(x+h,y-h) - f(x-h,y+h) + f(x-h,y-h)}{4h^2}
\]

\textbf{Nota:} Se utilizó 70\% de IA para la generación de este código.

\subsection{4.8 h) D[f(x,y),\{x,3\}]}

Tercera derivada parcial de una función bivariada $f(x,y)$ respecto a $x$. Se implementó el cálculo usando diferencias finitas centrales:

\[
\frac{\partial^3 f}{\partial x^3} \approx \frac{f(x+2h,y) - 2f(x+h,y) + 2f(x-h,y) - f(x-2h,y)}{2h^3}
\]

\textbf{Nota:} Se utilizó 70\% de IA para la generación de este código.

\subsection{Gráficos generados por el Programa 4}

La Figura 4 muestra la función y sus diferentes derivadas calculadas numéricamente.

\begin{center}
  \includegraphics[height=7cm]{derivadas_grafico.png}\\
  Figura 4: Derivadas numéricas de $f(x) = \sin(x) + x^2$.
\end{center}

\subsection{Análisis de resultados}
La Figura 4 presenta la primera derivada $f'(x)$ (línea azul), la segunda derivada $f''(x)$ (línea roja discontinua) y el punto de evaluación (punto verde) para la función $f(x) = \sin(x) + x^2$. Las derivadas numéricas calculadas coinciden con las derivadas analíticas esperadas, validando la implementación del método de diferencias finitas.

\newpage

\section{5. Ecuación diferencial y' (x)}

Resolución de ecuaciones diferenciales ordinarias de primer orden usando el método de Euler y Runge-Kutta de cuarto orden.

\subsection{Código}

Se implementó un programa en C++ que resuelve ecuaciones diferenciales de primer orden utilizando el método de Runge-Kutta de cuarto orden (RK4). El código compara la solución numérica con la solución exacta cuando está disponible y calcula el error absoluto.

\textbf{Nota:} Se utilizó 70\% de IA para la generación de este código.

\subsection{Gráficos generados por el Programa 5}

La Figura 5 compara las soluciones obtenidas por RK4 con la solución exacta para una EDO de primer orden.

\begin{center}
  \includegraphics[height=7cm]{rk4_grafico.png}\\
  Figura 5: Solución de la EDO $y' = x - y$ por método RK4.
\end{center}

\subsection{Análisis de resultados}
La Figura 5 presenta la solución RK4 (puntos y líneas azules), la solución exacta $y = x - 1 + 2e^{-x}$ (línea roja sólida) y el error absoluto (línea verde, eje Y2). El método de Runge-Kutta de cuarto orden proporciona alta precisión con errores menores al 0.1\% en todo el dominio.

\newpage

\section{6. Ecuación diferencial y'' (x)}

Resolución de ecuaciones diferenciales ordinarias de segundo orden reduciéndolas a sistemas de primer orden.

\subsection{Código}

Se desarrolló un programa en C++ que resuelve ecuaciones diferenciales de segundo orden mediante su transformación a un sistema de dos ecuaciones de primer orden. El código implementa el método de Runge-Kutta de cuarto orden para sistemas de ecuaciones.

\textbf{Nota:} Se utilizó 70\% de IA para la generación de este código.

\subsection{Gráficos generados por el Programa 6}

La Figura 6 muestra la solución y el plano de fase para una EDO de segundo orden.

\begin{center}
  \includegraphics[height=10cm]{ypp_grafico.png}\\
  Figura 6: Solución del oscilador armónico $y'' + y = 0$.
\end{center}

\subsection{Análisis de resultados}
La Figura 6 presenta dos subgráficos: superior muestra la solución $y(x)$ comparada con $\sin(x)$, e inferior muestra el plano de fase $y$ vs $y'$. La solución numérica coincide exactamente con la solución analítica $y(x) = \sin(x)$, validando la implementación del método para EDOs de segundo orden.

\newpage

\section{7. Sistema de ecuaciones diferenciales $\{x(t),y(t)\}$}

Implementación del modelo depredador-presa de Lotka-Volterra, un sistema clásico de ecuaciones diferenciales.

\subsection{Código}

Se implementó un programa en C++ que resuelve sistemas de ecuaciones diferenciales usando el método de Runge-Kutta de cuarto orden. El código genera trayectorias temporales y planos de fase para sistemas bidimensionales.

\textbf{Nota:} Se utilizó 70\% de IA para la generación de este código.

\subsection{Gráficos generados por el Programa 7}

La Figura 7 muestra la evolución temporal de las variables y el plano de fase del sistema.

\begin{center}
  \includegraphics[height=7cm]{sistema_temporal.png}\\
  Figura 7: Evolución temporal del sistema $dx/dt = y$, $dy/dt = -x$.
\end{center}

\subsection{Análisis de resultados}
La Figura 7 presenta las soluciones $x(t)$ e $y(t)$ vs tiempo. El sistema exhibe comportamiento oscilatorio característico, con las variables $x$ y $y$ desfasadas 90 grados. El plano de fase muestra una trayectoria circular cerrada, indicando un sistema conservativo con oscilaciones periódicas.

\section{Conclusiones}

Los 7 programas implementados demuestran la aplicación práctica de métodos numéricos fundamentales. Cada método fue validado mediante comparación con soluciones analíticas o mediante análisis de convergencia. La utilización de inteligencia artificial en la generación del código permitió acelerar el proceso de desarrollo mientras se mantuvo la calidad y precisión de las implementaciones.

\begin{flushright}
{\bf Fin del Reporte}
\end{flushright}

\end{document}
