\documentclass[12pt,a4]{article}
\usepackage[demo]{graphicx} % Opción demo para placeholders
\usepackage{graphics}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsbsy}
\usepackage{color}
\usepackage{listings}
\usepackage{lipsum}
\usepackage{url}
\usepackage{enumerate}
\usepackage{float}
\usepackage{hyperref}
\usepackage{authblk}
\lstset{
language=C++,
basicstyle=\footnotesize,
numbers=left,
numberstyle=\footnotesize,
stepnumber=1,
numbersep=10pt, 
backgroundcolor=\color{white},
showspaces=false,
showstringspaces=false,
showtabs=false,
tabsize=2,
captionpos=b, 
breaklines=true,
breakatwhitespace=false,
escapeinside={\%*}{*)}
}
\renewcommand{\lstlistingname}{Programa}
\renewcommand{\figurename}{Figura}
\renewcommand{\abstractname}{Resumen}
\renewcommand{\tablename}{Tabla}
\renewcommand{\refname}{Referencias}

\begin{document}
\begin{flushright}
{\bf Reporte:}\\
{\bf M\'etodos Num\'ericos}\\
{\bf O.Burgoa} \\
{\bf UPB}\\
{\bf 04/diciembre/2025}\\
{\bf Autor:}\\
{\bf J. Saenz}\\
\end{flushright}

\begin{abstract}
Se presentan 7 programas en lenguaje C que implementan diversos m\'etodos num\'ericos. El Programa 1 implementa el m\'etodo de Newton-Raphson para encontrar ra\'ices de ecuaciones. El Programa 2 resuelve sistemas de dos ecuaciones no lineales. El Programa 3 calcula la serie de Fourier de una funci\'on en un intervalo. Los programas 4, 5, 6 y 7 implementan c\'alculo de derivadas y soluci\'on de ecuaciones diferenciales mediante m\'etodos num\'ericos.
\end{abstract}

\section{Programa 1: Método de Newton-Raphson (utilizando derivadas)}

El Programa 1 implementa el m\'etodo de Newton-Raphson para encontrar ra\'ices de ecuaciones no lineales. Este m\'etodo iterativo utiliza derivadas para converger r\'apidamente a la soluci\'on.

\subsection{C\'odigo}

\begin{lstlisting}[label={prog1},caption={Implementaci\'on del m\'etodo de Newton-Raphson.}]
// 1_newton_raphson.c
// Metodo de Newton-Raphson con validaciones robustas

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <errno.h>

// ============================================================================

// ============================================================================
#define FUNCION(x)          ((x)*(x)*(x) - 2*(x) - 5)
#define DERIVADA(x)         (3*(x)*(x) - 2)
#define X_INICIAL           2.0
#define TOLERANCIA          1e-6
#define MAX_ITER            100
#define GRAFICO_INICIO      -3.0
#define GRAFICO_FIN         5.0
#define GRAFICO_PASO        0.1
#define NOMBRE_GRAFICO      "newton_grafico.png"
#define ANCHO_GRAFICO       800
#define ALTO_GRAFICO        600
// ============================================================================

// ============================================================================

// ============================================================================
int es_numerico_valido(double valor) {
    return !(isnan(valor) || isinf(valor) || fabs(valor) > 1e100);
}

void verificar_nan_inf(const char *nombre, double valor, int linea) {
    if (isnan(valor)) {
        printf(" ERROR en linea %d: %s = NaN (Not a Number)\n", linea, nombre);
        exit(EXIT_FAILURE);
    }
    if (isinf(valor)) {
        printf(" ERROR en linea %d: %s = Infinito\n", linea, nombre);
        exit(EXIT_FAILURE);
    }
    if (!es_numerico_valido(valor)) {
        printf(" ERROR en linea %d: %s = Valor numerico invalido\n", linea, nombre);
        exit(EXIT_FAILURE);
    }
}

#define VALIDAR(variable) verificar_nan_inf(#variable, variable, __LINE__)

FILE* abrir_archivo(const char *nombre, const char *modo) {
    FILE *archivo = fopen(nombre, modo);
    if (archivo == NULL) {
        printf(" ERROR: No se pudo abrir archivo '%s'\n", nombre);
        printf("   Verifique permisos o espacio en disco\n");
        exit(EXIT_FAILURE);
    }
    return archivo;
}

// ============================================================================
// FUNCIONES PRINCIPALES
// ============================================================================
void generar_datos_funcion() {
    FILE *func = abrir_archivo("funcion.dat", "w");
    fprintf(func, "# x f(x)\n");
    
    for (double xi = GRAFICO_INICIO; xi <= GRAFICO_FIN; xi += GRAFICO_PASO) {
        double fx = FUNCION(xi);
        VALIDAR(fx);
        fprintf(func, "%.3f %.3f\n", xi, fx);
    }
    fclose(func);
}

void crear_script_gnuplot(double raiz) {
    FILE *gp = abrir_archivo("newton_plot.gp", "w");
    
    fprintf(gp, "# Script Gnuplot para Newton-Raphson\n");
    fprintf(gp, "set terminal pngcairo size %d,%d enhanced font 'Arial,10'\n", 
            ANCHO_GRAFICO, ALTO_GRAFICO);
    fprintf(gp, "set output '%s'\n", NOMBRE_GRAFICO);
    fprintf(gp, "set title 'Metodo de Newton-Raphson: f(x) = x^3 - 2x - 5'\n");
    fprintf(gp, "set xlabel 'x'\n");
    fprintf(gp, "set ylabel 'f(x)'\n");
    fprintf(gp, "set grid\n");
    fprintf(gp, "set key top left box\n");
    fprintf(gp, "set zeroaxis lt -1\n\n");
    
    fprintf(gp, "plot 'funcion.dat' with lines lw 2 lc rgb 'blue' title 'f(x)', \\\n");
    fprintf(gp, "     0 with lines lc rgb 'black' notitle, \\\n");
    fprintf(gp, "     'iteraciones.dat' using 2:3 with points \\\n");
    fprintf(gp, "        pt 7 ps 1.5 lc rgb 'red' title 'Iteraciones', \\\n");
    fprintf(gp, "     %lf, 0 with points pt 9 ps 2 lc rgb 'green' title 'Raiz: %.6f'\n", 
            raiz, raiz);
    
    fclose(gp);
}

int ejecutar_gnuplot() {
    printf("\n Generando grafico...\n");
    int resultado = system("gnuplot newton_plot.gp 2>&1");
    
    if (resultado != 0) {
        printf(" ADVERTENCIA: Gnuplot encontro problemas\n");
        printf("   Verifique que Gnuplot este instalado: gnuplot --version\n");
        printf("   Puede generar el grafico manualmente con:\n");
        printf("   gnuplot newton_plot.gp\n");
        return 0;
    }
    
    printf(" Grafico generado exitosamente: %s\n", NOMBRE_GRAFICO);
    return 1;
}

int main() {
    double x = X_INICIAL, x_nuevo, error;
    int iter = 0;
    
    // ============================================================================
    // VALIDACION INICIAL DE PARAMS
    // ============================================================================
    printf(" Validando parametros iniciales...\n");
    
    if (!es_numerico_valido(X_INICIAL)) {
        printf("ERROR: Valor inicial X_INICIAL invalido: %f\n", X_INICIAL);
        return EXIT_FAILURE;
    }
    
    if (TOLERANCIA <= 0) {
        printf("ERROR: TOLERANCIA debe ser positiva: %e\n", TOLERANCIA);
        return EXIT_FAILURE;
    }
    
    if (MAX_ITER <= 0) {
        printf("ERROR: MAX_ITER debe ser positivo: %d\n", MAX_ITER);
        return EXIT_FAILURE;
    }
    
    double fx_inicial = FUNCION(x);
    double dfx_inicial = DERIVADA(x);
    
    VALIDAR(fx_inicial);
    VALIDAR(dfx_inicial);
    
    printf("Parametros validados correctamente\n\n");
    
    // ============================================================================

    // ============================================================================
    printf(" METODO DE NEWTON-RAPHSON \n\n");
    
    printf("CONFIGURACION:\n");
    printf("  Funcion:          f(x) = x3 - 2x - 5\n");
    printf("  Valor inicial:    x0 = %.1f, f(x0) = %.3f\n", X_INICIAL, fx_inicial);
    printf("  Derivada inicial: f'(x0) = %.3f\n", dfx_inicial);
    printf("  Tolerancia:       %.1e\n", TOLERANCIA);
    printf("  Max iteraciones:  %d\n\n", MAX_ITER);
    
    // Archivos
    FILE *datos = abrir_archivo("iteraciones.dat", "w");
    fprintf(datos, "# iter x f(x) error\n");
    
    generar_datos_funcion();
    
    printf("PROCESO DE CALCULO:\n");
    printf("+-----+-----------+-----------+-----------+-----------+\n");
    printf("| Iter|    x      |   f(x)    |  f'(x)    |  Error    |\n");
    printf("+-----+-----------+-----------+-----------+-----------+\n");
    
    // ============================================================================
    // NEWTON-RAPHSON CON VALIDACIONES
    // ============================================================================
    do {
        double fx = FUNCION(x);
        double dfx = DERIVADA(x);
        
        VALIDAR(fx);
        VALIDAR(dfx);
        
        // Validacion de derivada
        if (fabs(dfx) < 1e-15) {
            printf("+-----+-----------+-----------+-----------+-----------+\n");
            printf("| ERROR CRITICO: Derivada cero (%.2e)                |\n", dfx);
            printf("|   en x = %.6f                                        |\n", x);
            printf("|   f(x) = %.6f                                        |\n", fx);
            printf("|   El metodo no puede continuar                        |\n");
            printf("+-----------------------------------------------------+\n");
            fclose(datos);
            return EXIT_FAILURE;
        }
        
        // nueva aproximacion
        x_nuevo = x - fx / dfx;
        VALIDAR(x_nuevo);
        
        error = fabs(x_nuevo - x);
        VALIDAR(error);
        
        //  divergencia
        if (error > 1e10 && iter > 5) {
            printf("+-----+-----------+-----------+-----------+-----------+\n");
            printf("| ADVERTENCIA: Posible divergencia                   |\n");
            printf("|   Error creciente: %.2e                            |\n", error);
            printf("|   Considere cambiar el valor inicial                 |\n");
            printf("+-----------------------------------------------------+\n");
            break;
        }
        
        // Mostrar y guardar
        printf("| %3d | %9.6f | %9.6f | %9.6f | %9.6f |\n", 
               iter, x, fx, dfx, error);
        
        fprintf(datos, "%d %.6f %.6f %.6f\n", iter, x, fx, error);
        
        // Actualizar
        x = x_nuevo;
        iter++;
        
        // Verificar convergencia
        if (error < TOLERANCIA) {
            printf("+-----+-----------+-----------+-----------+-----------+\n");
            printf("| CONVERGENCIA ALCANZADA                            |\n");
            printf("|   Error final: %.2e < Tolerancia: %.2e           |\n", 
                   error, TOLERANCIA);
            printf("+-----------------------------------------------------+\n\n");
            break;
        }
        
        // Verificar max de iteraciones
        if (iter >= MAX_ITER) {
            printf("+-----+-----------+-----------+-----------+-----------+\n");
            printf("| LIMITE DE ITERACIONES ALCANZADO                    |\n");
            printf("|   No se alcanzo la tolerancia en %d iteraciones     |\n", MAX_ITER);
            printf("|   Ultimo error: %.2e                            |\n", error);
            printf("+-----------------------------------------------------+\n\n");
            break;
        }
        
    } while (1);
    
    fclose(datos);
    
    // Validar resultado final
    double fx_final = FUNCION(x);
    VALIDAR(fx_final);
    
    if (fabs(fx_final) > 0.1) {
        printf(" ADVERTENCIA: Valor de funcion en raiz es alto: %.2e\n", fx_final);
        printf("   La raiz podria no ser precisa\n");
    }
    
    // ============================================================================
    // GENERAR 
    // ============================================================================
    crear_script_gnuplot(x);
    int grafico_ok = ejecutar_gnuplot();
    
    // ============================================================================
    // RESULTADOS FINALES
    // ============================================================================
    printf("\n RESULTADOS FINALES:\n");
    printf("-------------------------------------------------------------\n");
    printf("  Raiz aproximada:  x = %.8f\n", x);
    printf("  f(raiz) =         %.2e\n", fx_final);
    printf("  Iteraciones:      %d de %d\n", iter, MAX_ITER);
    printf("  Error final:      %.2e (Tolerancia: %.2e)\n", error, TOLERANCIA);
    printf("  Estado:           %s\n", 
           (error < TOLERANCIA) ? "CONVERGENCIA" : "ITERACIONES MAXIMAS");
    printf("  Grafico:          %s\n", 
           grafico_ok ? "GENERADO CORRECTAMENTE" : "NO SE PUDO GENERAR");
    
    printf("\n ARCHIVOS GENERADOS:\n");
    printf("-------------------------------------------------------------\n");
    printf("  - iteraciones.dat   -> %d iteraciones guardadas\n", iter);
    printf("  - funcion.dat       -> Puntos para graficar\n");
    printf("  - newton_plot.gp    -> Script de Gnuplot\n");
    if (grafico_ok) {
        printf("  - %s -> Grafico final\n", NOMBRE_GRAFICO);
    }
    
    return EXIT_SUCCESS;
}
double df(double x) {
    return 2*x; // Derivada: 2x
}
\end{lstlisting}

\subsection{Gr\'aficos generados por el Programa 1}

La Figura 1 muestra la convergencia del m\'etodo de Newton-Raphson hacia la ra\'iz de la funci\'on.
\begin{center}
  \includegraphics[height=7cm]{newton1}\\
  Figura 1: Convergencia del m\'etodo de Newton-Raphson.
\end{center}

\subsection{An\'alisis de resultados}
En la Figura 1 se observa c\'omo el m\'etodo converge r\'apidamente a la ra\'iz, mostrando la eficiencia del algoritmo cuando la derivada est\'a disponible.

\subsection{Verificaci\'on}
La Figura 2 muestra la comparaci\'on con el valor anal\'itico exacto.
\begin{center}
  \includegraphics[height=7cm]{newton2}\\
  Figura 2: Verificaci\'on del resultado con soluci\'on anal\'itica.
\end{center}

\newpage

\section{Programa 2: Sistema de dos ecuaciones no lineales}

El Programa 2 implementa la soluci\'on num\'erica de sistemas de dos ecuaciones no lineales mediante el m\'etodo de Newton para sistemas.

\subsection{C\'odigo}

\begin{lstlisting}[label={prog2},caption={Soluci\'on de sistema de ecuaciones no lineales.}]
// 2_newton_sistemas.c
// Newton para sistemas con validaciones robustas

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <errno.h>

// ============================================================================
// PARAMETROS CONFIGURABLES
// ============================================================================
#define F1(x,y)             ((x)*(x) + (y)*(y) - 4)
#define F2(x,y)             (exp(x) + (y) - 1)
#define DF1_DX(x,y)         (2*(x))
#define DF1_DY(x,y)         (2*(y))
#define DF2_DX(x,y)         (exp(x))
#define DF2_DY(x,y)         (1)
#define X_INICIAL           1.0
#define Y_INICIAL           1.0
#define TOLERANCIA          1e-6
#define MAX_ITER            50
#define GRAFICO_RANGO_X     3.0
#define GRAFICO_RANGO_Y     3.0
#define GRAFICO_PUNTOS      200
#define NOMBRE_GRAFICO      "sistema_grafico.png"
#define ANCHO_GRAFICO       900
#define ALTO_GRAFICO        700
// ============================================================================

// ============================================================================
// FUNCIONES DE VALIDACION
// ============================================================================
int es_numerico_valido(double valor) {
    return !(isnan(valor) || isinf(valor) || fabs(valor) > 1e100);
}

void verificar_nan_inf(const char *nombre, double valor, int linea) {
    if (isnan(valor)) {
        printf("ERROR en linea %d: %s = NaN\n", linea, nombre);
        exit(EXIT_FAILURE);
    }
    if (isinf(valor)) {
        printf("ERROR en linea %d: %s = Infinito\n", linea, nombre);
        exit(EXIT_FAILURE);
    }
    if (!es_numerico_valido(valor)) {
        printf("ERROR en linea %d: %s = Valor invalido\n", linea, nombre);
        exit(EXIT_FAILURE);
    }
}

#define VALIDAR(variable) verificar_nan_inf(#variable, variable, __LINE__)

void validar_punto(double x, double y, const char *contexto) {
    if (!es_numerico_valido(x) || !es_numerico_valido(y)) {
        printf("ERROR en %s: Punto invalido (%.6f, %.6f)\n", contexto, x, y);
        exit(EXIT_FAILURE);
    }
}

FILE* abrir_archivo(const char *nombre, const char *modo) {
    FILE *archivo = fopen(nombre, modo);
    if (archivo == NULL) {
        printf("ERROR: No se pudo abrir '%s' (modo: %s)\n", nombre, modo);
        printf("   errno: %d\n", errno);
        exit(EXIT_FAILURE);
    }
    return archivo;
}

// ============================================================================
// FUNCIONES PRINCIPALES
// ============================================================================
void generar_datos_curvas() {
    FILE *curvas = abrir_archivo("sistema_curvas.dat", "w");
    
    fprintf(curvas, "# Curva 1: x^2 + y^2 = 4\n");
    for (int i = 0; i <= GRAFICO_PUNTOS; i++) {
        double t = 2 * M_PI * i / GRAFICO_PUNTOS;
        double x = 2 * cos(t);
        double y = 2 * sin(t);
        VALIDAR(x); VALIDAR(y);
        fprintf(curvas, "%.6f %.6f\n", x, y);
    }
    fprintf(curvas, "\n\n# Curva 2: e^x + y = 1\n");
    for (int i = 0; i <= GRAFICO_PUNTOS; i++) {
        double xi = -GRAFICO_RANGO_X + (2*GRAFICO_RANGO_X * i / GRAFICO_PUNTOS);
        double yi = 1 - exp(xi);
        VALIDAR(xi); VALIDAR(yi);
        fprintf(curvas, "%.6f %.6f\n", xi, yi);
    }
    fclose(curvas);
}

void crear_script_gnuplot(double sol_x, double sol_y) {
    FILE *gp = abrir_archivo("sistema_plot.gp", "w");
    
    fprintf(gp, "# Script para sistema de ecuaciones\n");
    fprintf(gp, "set terminal pngcairo size %d,%d enhanced font 'Arial,10'\n", 
            ANCHO_GRAFICO, ALTO_GRAFICO);
    fprintf(gp, "set output '%s'\n", NOMBRE_GRAFICO);
    fprintf(gp, "set title 'Sistema: x^2+y^2=4 y e^x+y=1'\n");
    fprintf(gp, "set xlabel 'x'\n");
    fprintf(gp, "set ylabel 'y'\n");
    fprintf(gp, "set grid\n");
    fprintf(gp, "set size ratio -1\n");
    fprintf(gp, "set xrange [%lf:%lf]\n", -GRAFICO_RANGO_X, GRAFICO_RANGO_X);
    fprintf(gp, "set yrange [%lf:%lf]\n", -GRAFICO_RANGO_Y, GRAFICO_RANGO_Y);
    fprintf(gp, "set key box opaque\n\n");
    
    fprintf(gp, "plot 'sistema_curvas.dat' index 0 w l lw 2 lc rgb '#0066CC' title 'x^2 + y^2 = 4', \\\n");
    fprintf(gp, "     'sistema_curvas.dat' index 1 w l lw 2 lc rgb '#CC0066' title 'e^x + y = 1', \\\n");
    fprintf(gp, "     'sistema_trayectoria.dat' w l lw 1.5 lc rgb '#00AA00' title 'Trayectoria Newton', \\\n");
    fprintf(gp, "     'sistema_trayectoria.dat' w p pt 7 ps 1 lc rgb '#00AA00' notitle, \\\n");
    fprintf(gp, "     %lf, %lf w p pt 9 ps 2 lc rgb '#000000' title 'Solucion: (%.4f, %.4f)'\n", 
            sol_x, sol_y, sol_x, sol_y);
    
    fclose(gp);
}

int ejecutar_gnuplot() {
    printf("\nGenerando grafico...\n");
    int resultado = system("gnuplot sistema_plot.gp 2>&1");
    
    if (resultado != 0) {
        printf("ADVERTENCIA: Error al ejecutar Gnuplot\n");
        printf("   Comando fallido: gnuplot sistema_plot.gp\n");
        return 0;
    }
    
    printf("EXITO: Grafico generado: %s\n", NOMBRE_GRAFICO);
    return 1;
}

int main() {
    double x = X_INICIAL, y = Y_INICIAL, error;
    int iteracion = 0;
    
    // ============================================================================
    // VALIDACION INICIAL
    // ============================================================================
    printf("Validando parametros iniciales...\n");
    
    validar_punto(x, y, "punto inicial");
    
    double f1_inicial = F1(x, y);
    double f2_inicial = F2(x, y);
    VALIDAR(f1_inicial);
    VALIDAR(f2_inicial);
    
    if (TOLERANCIA <= 0) {
        printf("ERROR: TOLERANCIA debe ser positiva\n");
        return EXIT_FAILURE;
    }
    
    printf("EXITO: Validacion inicial exitosa\n");
    printf("   f1(%.1f, %.1f) = %.3f\n", x, y, f1_inicial);
    printf("   f2(%.1f, %.1f) = %.3f\n\n", x, y, f2_inicial);
    
    // ============================================================================
    // CONFIGURACION
    // ============================================================================
    printf("===============================================================\n");
    printf("          SISTEMA DE ECUACIONES NO LINEALES (2D)              \n");
    printf("===============================================================\n\n");
    
    printf("PROCESO DE CALCULO:\n");
    printf("================================================================================\n");
    printf("| Iter|     x     |     y     |    f1     |    f2     |  Det(J)   |  Error    |\n");
    printf("================================================================================\n");
    
    // Archivos
    FILE *datos_iter = abrir_archivo("sistema_iteraciones.dat", "w");
    FILE *datos_tray = abrir_archivo("sistema_trayectoria.dat", "w");
    
    fprintf(datos_iter, "# iter x y f1 f2 det_j error\n");
    fprintf(datos_tray, "%.6f %.6f\n", x, y);
    
    // ============================================================================
    // METODO DE NEWTON CON VALIDACIONES
    // ============================================================================
    do {
        double f1 = F1(x, y);
        double f2 = F2(x, y);
        VALIDAR(f1); VALIDAR(f2);
        
        // Jacobiano
        double df1_dx = DF1_DX(x, y);
        double df1_dy = DF1_DY(x, y);
        double df2_dx = DF2_DX(x, y);
        double df2_dy = DF2_DY(x, y);
        
        VALIDAR(df1_dx); VALIDAR(df1_dy);
        VALIDAR(df2_dx); VALIDAR(df2_dy);
        
        double det = df1_dx*df2_dy - df1_dy*df2_dx;
        VALIDAR(det);
        
        // Validacion de Jacobiano
        if (fabs(det) < 1e-15) {
            printf("================================================================================\n");
            printf("| ERROR CRITICO: Jacobiano singular                                          |\n");
            printf("|   det(J) = %.2e en (%.6f, %.6f)                             |\n", det, x, y);
            printf("|   f1 = %.6f, f2 = %.6f                                       |\n", f1, f2);
            printf("================================================================================\n");
            fclose(datos_iter);
            fclose(datos_tray);
            return EXIT_FAILURE;
        }
        
        // Resolver sistema
        double dx = (-f1*df2_dy + f2*df1_dy) / det;
        double dy = (-df1_dx*f2 + f1*df2_dx) / det;
        
        VALIDAR(dx); VALIDAR(dy);
        
        error = sqrt(dx*dx + dy*dy);
        VALIDAR(error);
        
        // Mostrar resultados
        printf("| %3d | %9.6f | %9.6f | %9.6f | %9.6f | %9.2e | %9.6f |\n", 
               iteracion, x, y, f1, f2, det, error);
        
        // Guardar
        fprintf(datos_iter, "%d %.6f %.6f %.6f %.6f %.6e %.6f\n", 
                iteracion, x, y, f1, f2, det, error);
        
        // Actualizar con validacion
        double x_nuevo = x + dx;
        double y_nuevo = y + dy;
        
        validar_punto(x_nuevo, y_nuevo, "nuevo punto");
        
        x = x_nuevo;
        y = y_nuevo;
        
        fprintf(datos_tray, "%.6f %.6f\n", x, y);
        iteracion++;
        
        // Deteccion de divergencia
        if (error > 1e5 && iteracion > 3) {
            printf("================================================================================\n");
            printf("| ADVERTENCIA: Posible divergencia                                           |\n");
            printf("|   Error creciente: %.2e                                                    |\n", error);
            printf("================================================================================\n");
            break;
        }
        
        // Verificar convergencia
        if (error < TOLERANCIA) {
            printf("================================================================================\n");
            printf("| EXITO: CONVERGENCIA ALCANZADA                                              |\n");
            printf("|   Error: %.2e < Tolerancia: %.2e                                       |\n", 
                   error, TOLERANCIA);
            printf("================================================================================\n");
            break;
        }
        
        if (iteracion >= MAX_ITER) {
            printf("================================================================================\n");
            printf("| ADVERTENCIA: LIMITE DE ITERACIONES                                         |\n");
            printf("|   No convergio en %d iteraciones                                          |\n", MAX_ITER);
            printf("|   Ultimo error: %.2e                                                    |\n", error);
            printf("================================================================================\n");
            break;
        }
        
    } while (1);
    
    fclose(datos_iter);
    fclose(datos_tray);
    
    // ============================================================================
    // VALIDACION DE SOLUCION FINAL
    // ============================================================================
    printf("\nValidando solucion final...\n");
    
    double f1_final = F1(x, y);
    double f2_final = F2(x, y);
    VALIDAR(f1_final); VALIDAR(f2_final);
    
    double error_f1 = fabs(f1_final);
    double error_f2 = fabs(f2_final);
    
    if (error_f1 > 0.01 || error_f2 > 0.01) {
        printf("ADVERTENCIA: La solucion no satisface bien las ecuaciones\n");
        printf("   f1(x,y) = %.2e (deberia ser ~0)\n", error_f1);
        printf("   f2(x,y) = %.2e (deberia ser ~0)\n", error_f2);
    } else {
        printf("EXITO: Solucion valida las ecuaciones\n");
    }
    
    // ============================================================================
    // GENERAR GRAFICOS
    // ============================================================================
    generar_datos_curvas();
    crear_script_gnuplot(x, y);
    int grafico_ok = ejecutar_gnuplot();
    
    // ============================================================================
    // RESULTADOS FINALES
    // ============================================================================
    printf("\nRESULTADOS FINALES:\n");
    printf("-----------------------------------------------------------------\n");
    printf("  Solucion:         x = %.8f, y = %.8f\n", x, y);
    printf("  f1(x,y) =         %.2e\n", f1_final);
    printf("  f2(x,y) =         %.2e\n", f2_final);
    printf("  Iteraciones:      %d de %d\n", iteracion, MAX_ITER);
    printf("  Error final:      %.2e\n", error);
    printf("  Estado:           %s\n", 
           (error < TOLERANCIA) ? "CONVERGENCIA" : "ITERACIONES MAXIMAS");
    
    printf("\nARCHIVOS GENERADOS:\n");
    printf("-----------------------------------------------------------------\n");
    printf("  EXITO: sistema_iteraciones.dat -> %d iteraciones\n", iteracion);
    printf("  EXITO: sistema_trayectoria.dat -> Trayectoria completa\n");
    printf("  EXITO: sistema_curvas.dat      -> Curvas de ecuaciones\n");
    printf("  EXITO: sistema_plot.gp         -> Script Gnuplot\n");
    if (grafico_ok) {
        printf("  EXITO: %s       -> Grafico final\n", NOMBRE_GRAFICO);
    }
    
    printf("\n===============================================================\n");
    printf("                      EJECUCION COMPLETADA                     \n");
    printf("===============================================================\n");
    
    return EXIT_SUCCESS;
}
\end{lstlisting}

\subsection{Gr\'aficos generados por el Programa 2}

La Figura 3 muestra las curvas de nivel del sistema y los puntos de intersecci\'on encontrados.
\begin{center}
  \includegraphics[height=7cm]{sistema1}\\
  Figura 3: Curvas de nivel y soluciones del sistema.
\end{center}

\subsection{An\'alisis de resultados}
La Figura 3 ilustra las soluciones encontradas como puntos de intersecci\'on entre las curvas definidas por las ecuaciones.

\subsection{Verificaci\'on}
\begin{center}
  \includegraphics[height=7cm]{sistema2}\\
  Figura 4: Validaci\'on de las soluciones encontradas.
\end{center}

\newpage

\section{Programa 3: Serie de Fourier de una función en intervalo [0,2L] (con gráfica)}

El Programa 3 calcula los coeficientes de Fourier y reconstruye una funci\'on peri\'odica en el intervalo [0,2L], mostrando la convergencia de la serie.

\subsection{C\'odigo}

\begin{lstlisting}[label={prog3},caption={C\'alculo de serie de Fourier.}]
// 3_fourier.c
// Serie de Fourier con validaciones robustas

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <errno.h>

// ============================================================================
// PARAMETROS CONFIGURABLES
// ============================================================================
#define FUNCION_ORIGINAL(x) ((x) < L ? (x) : (2*L - (x)))
#define L                   M_PI
#define N_TERMINOS          10
#define PUNTOS_GRAFICO      500
#define GRAFICO_INICIO      0.0
#define GRAFICO_FIN         2*M_PI
#define NOMBRE_GRAFICO      "fourier_grafico.png"
#define ANCHO_GRAFICO       800
#define ALTO_GRAFICO        600
// ============================================================================

// ============================================================================
// FUNCIONES DE VALIDACION
// ============================================================================
int es_numerico_valido(double valor) {
    return !(isnan(valor) || isinf(valor) || fabs(valor) > 1e100);
}

void verificar_nan_inf(const char *nombre, double valor, int linea) {
    if (isnan(valor)) {
        printf("ERROR en linea %d: %s = NaN\n", linea, nombre);
        exit(EXIT_FAILURE);
    }
    if (isinf(valor)) {
        printf("ERROR en linea %d: %s = Infinito\n", linea, nombre);
        exit(EXIT_FAILURE);
    }
}

#define VALIDAR(variable) verificar_nan_inf(#variable, variable, __LINE__)

FILE* abrir_archivo(const char *nombre, const char *modo) {
    FILE *archivo = fopen(nombre, modo);
    if (archivo == NULL) {
        printf("ERROR: No se pudo abrir '%s'\n", nombre);
        exit(EXIT_FAILURE);
    }
    return archivo;
}

// ============================================================================
// VALIDACION DE PARAMETROS
// ============================================================================
void validar_parametros() {
    printf("Validando parametros...\n");
    
    if (L <= 0) {
        printf("ERROR: L debe ser positivo (L = %f)\n", L);
        exit(EXIT_FAILURE);
    }
    
    if (N_TERMINOS <= 0) {
        printf("ERROR: N_TERMINOS debe ser positivo (%d)\n", N_TERMINOS);
        exit(EXIT_FAILURE);
    }
    
    if (PUNTOS_GRAFICO < 10) {
        printf("ERROR: PUNTOS_GRAFICO debe ser >= 10 (%d)\n", PUNTOS_GRAFICO);
        exit(EXIT_FAILURE);
    }
    
    if (GRAFICO_FIN <= GRAFICO_INICIO) {
        printf("ERROR: GRAFICO_FIN debe ser > GRAFICO_INICIO\n");
        exit(EXIT_FAILURE);
    }
    
    // Validar funcion en algunos puntos
    for (int i = 0; i < 5; i++) {
        double x = GRAFICO_INICIO + i * (GRAFICO_FIN - GRAFICO_INICIO) / 4;
        double fx = FUNCION_ORIGINAL(x);
        VALIDAR(fx);
        
        if (!es_numerico_valido(fx)) {
            printf("ERROR: Funcion invalida en x = %f\n", x);
            exit(EXIT_FAILURE);
        }
    }
    
    printf("Parametros validados correctamente\n\n");
}

// ============================================================================
// FUNCIONES PRINCIPALES
// ============================================================================
int main() {
    validar_parametros();
    
    printf("==============================================================\n");
    printf("                    SERIE DE FOURIER                          \n");
    printf("==============================================================\n\n");
    
    printf("CONFIGURACION:\n");
    printf("  Funcion:          Triangular en [0, 2pi]\n");
    printf("  Periodo:          L = pi\n");
    printf("  Terminos:         %d\n", N_TERMINOS);
    printf("  Puntos grafico:   %d\n\n", PUNTOS_GRAFICO);
    
    // ============================================================================
    // CALCULAR COEFICIENTES CON VALIDACION
    // ============================================================================
    printf("CALCULANDO COEFICIENTES...\n");
    printf("-------------------------------------------------------------\n");
    
    double a0 = 0.0;
    double an[N_TERMINOS + 1], bn[N_TERMINOS + 1];
    
    int puntos_int = 1000;
    double dx_int = 2*L / puntos_int;
    VALIDAR(dx_int);
    
    if (dx_int <= 0) {
        printf("ERROR: dx_int no valido: %f\n", dx_int);
        return EXIT_FAILURE;
    }
    
    // Calcular a0
    for (int i = 0; i < puntos_int; i++) {
        double x = i * dx_int;
        double f = FUNCION_ORIGINAL(x);
        VALIDAR(f);
        
        if (!es_numerico_valido(f)) {
            printf("ERROR: Funcion invalida en x = %f, f(x) = %f\n", x, f);
            return EXIT_FAILURE;
        }
        
        a0 += f;
        VALIDAR(a0);
    }
    a0 *= dx_int / L;
    VALIDAR(a0);
    
    printf("  Coeficiente a0 = %.6f\n", a0);
    
    // Calcular coeficientes an y bn
    for (int n = 1; n <= N_TERMINOS; n++) {
        double suma_an = 0.0, suma_bn = 0.0;
        
        for (int i = 0; i < puntos_int; i++) {
            double x = i * dx_int;
            double f = FUNCION_ORIGINAL(x);
            VALIDAR(f);
            
            double cos_val = cos(n * M_PI * x / L);
            double sin_val = sin(n * M_PI * x / L);
            VALIDAR(cos_val); VALIDAR(sin_val);
            
            suma_an += f * cos_val;
            suma_bn += f * sin_val;
            
            VALIDAR(suma_an); VALIDAR(suma_bn);
            
            // Detectar overflow
            if (fabs(suma_an) > 1e50 || fabs(suma_bn) > 1e50) {
                printf("ERROR: Overflow en calculo de coeficientes n=%d\n", n);
                return EXIT_FAILURE;
            }
        }
        
        an[n] = suma_an * dx_int / L;
        bn[n] = suma_bn * dx_int / L;
        
        VALIDAR(an[n]); VALIDAR(bn[n]);
        
        if (n <= 5) {
            printf("  a%d = %9.6f, b%d = %9.6f\n", n, an[n], n, bn[n]);
        }
    }
    
    // ============================================================================
    // GENERAR DATOS CON VALIDACION
    // ============================================================================
    printf("\nGENERANDO DATOS...\n");
    printf("-------------------------------------------------------------\n");
    
    FILE *orig = abrir_archivo("fourier_original.dat", "w");
    FILE *serie = abrir_archivo("fourier_serie.dat", "w");
    FILE *script_gp = abrir_archivo("fourier_plot.gp", "w");
    
    fprintf(orig, "# Funcion original\n");
    fprintf(serie, "# Aproximacion de Fourier\n");
    
    double dx = (GRAFICO_FIN - GRAFICO_INICIO) / PUNTOS_GRAFICO;
    VALIDAR(dx);
    
    int errores_puntos = 0;
    
    for (int i = 0; i <= PUNTOS_GRAFICO; i++) {
        double x = GRAFICO_INICIO + i * dx;
        VALIDAR(x);
        
        // Funcion original
        double f_orig = FUNCION_ORIGINAL(x);
        VALIDAR(f_orig);
        
        // Serie de Fourier
        double f_serie = a0 / 2;
        VALIDAR(f_serie);
        
        for (int n = 1; n <= N_TERMINOS; n++) {
            double termino = an[n] * cos(n * M_PI * x / L) + bn[n] * sin(n * M_PI * x / L);
            VALIDAR(termino);
            
            f_serie += termino;
            VALIDAR(f_serie);
            
            // Detectar divergencia
            if (!es_numerico_valido(f_serie)) {
                printf("ADVERTENCIA: Serie divergente en x=%.3f, n=%d\n", x, n);
                errores_puntos++;
                f_serie = 0; // Reset para continuar
                break;
            }
        }
        
        // Guardar si ambos valores son validos
        if (es_numerico_valido(f_orig) && es_numerico_valido(f_serie)) {
            fprintf(orig, "%.6f %.6f\n", x, f_orig);
            fprintf(serie, "%.6f %.6f\n", x, f_serie);
        } else {
            errores_puntos++;
        }
        
        // Progreso
        if (i % (PUNTOS_GRAFICO/10) == 0) {
            printf("  %3d%%: x=%.3f, f(x)=%.3f, Fourier=%.3f\n", 
                   (i*100)/PUNTOS_GRAFICO, x, f_orig, f_serie);
        }
    }
    
    fclose(orig);
    fclose(serie);
    
    if (errores_puntos > 0) {
        printf("ADVERTENCIA: %d puntos tuvieron problemas numericos\n", errores_puntos);
    }
    
    // ============================================================================
    // CREAR SCRIPT GNUPLOT
    // ============================================================================
    fprintf(script_gp, "# Script para serie de Fourier\n");
    fprintf(script_gp, "set terminal pngcairo size %d,%d enhanced font 'Arial,10'\n", 
            ANCHO_GRAFICO, ALTO_GRAFICO);
    fprintf(script_gp, "set output '%s'\n", NOMBRE_GRAFICO);
    fprintf(script_gp, "set title 'Serie de Fourier (N = %d terminos)'\n", N_TERMINOS);
    fprintf(script_gp, "set xlabel 'x'\n");
    fprintf(script_gp, "set ylabel 'f(x)'\n");
    fprintf(script_gp, "set grid\n");
    fprintf(script_gp, "set key top left box\n");
    fprintf(script_gp, "set xrange [%f:%f]\n", GRAFICO_INICIO, GRAFICO_FIN);
    fprintf(script_gp, "set yrange [-0.5:4.5]\n\n");
    
    fprintf(script_gp, "plot 'fourier_original.dat' w l lw 3 lc rgb '#0066CC' title 'Funcion original', \\\n");
    fprintf(script_gp, "     'fourier_serie.dat' w l lw 2 lc rgb '#FF3333' dt 2 title 'Aproximacion Fourier'\n");
    
    fclose(script_gp);
    
    // ============================================================================
    // EJECUTAR GNUPLOT
    // ============================================================================
    printf("\nGENERANDO GRAFICO...\n");
    printf("-------------------------------------------------------------\n");
    
    int resultado = system("gnuplot fourier_plot.gp 2>&1");
    
    if (resultado != 0) {
        printf("ADVERTENCIA: Problema al generar grafico\n");
    } else {
        printf("Grafico generado: %s\n", NOMBRE_GRAFICO);
    }
    
    // ============================================================================
    // ANALISIS DE ERROR
    // ============================================================================
    printf("\nANALISIS DE ERROR:\n");
    printf("-------------------------------------------------------------\n");
    
    double error_cuadratico = 0.0;
    double error_maximo = 0.0;
    int puntos_error = 100;
    int puntos_validos = 0;
    
    for (int i = 0; i <= puntos_error; i++) {
        double x = GRAFICO_INICIO + i * (GRAFICO_FIN - GRAFICO_INICIO) / puntos_error;
        double f_orig = FUNCION_ORIGINAL(x);
        double f_serie = a0 / 2;
        
        for (int n = 1; n <= N_TERMINOS; n++) {
            f_serie += an[n] * cos(n * M_PI * x / L) + bn[n] * sin(n * M_PI * x / L);
        }
        
        if (es_numerico_valido(f_orig) && es_numerico_valido(f_serie)) {
            double error = fabs(f_orig - f_serie);
            error_cuadratico += error * error;
            if (error > error_maximo) error_maximo = error;
            puntos_validos++;
        }
    }
    
    if (puntos_validos > 0) {
        error_cuadratico = sqrt(error_cuadratico / puntos_validos);
        printf("  Error cuadratico medio: %.6f\n", error_cuadratico);
        printf("  Error maximo:           %.6f\n", error_maximo);
        printf("  Puntos analizados:      %d/%d\n", puntos_validos, puntos_error + 1);
    } else {
        printf("ERROR: No se pudieron calcular errores\n");
    }
    
    // ============================================================================
    // RESUMEN
    // ============================================================================
    printf("\nRESUMEN:\n");
    printf("-------------------------------------------------------------\n");
    printf("  Terminos calculados:  %d\n", N_TERMINOS);
    printf("  Puntos generados:     %d\n", PUNTOS_GRAFICO + 1);
    printf("  Errores encontrados:  %d\n", errores_puntos);
    printf("  Grafico:              %s\n", 
           (resultado == 0) ? "GENERADO" : "NO GENERADO");
    
    printf("\n==============================================================\n");
    printf("                      EJECUCION COMPLETADA                     \n");
    printf("==============================================================\n");
    
    return EXIT_SUCCESS;
}
\end{lstlisting}

\subsection{Gr\'aficos generados por el Programa 3}

La Figura 5 muestra la funci\'on original y su aproximaci\'on por series de Fourier con diferente n\'umero de t\'erminos.
\begin{center}
  \includegraphics[height=7cm]{fourier1}\\
  Figura 5: Aproximaci\'on por serie de Fourier.
\end{center}

\subsection{An\'alisis de resultados}
La Figura 5 presenta c\'omo aumenta la precisi\'on de la aproximaci\'on al incrementar el n\'umero de t\'erminos de la serie.

\subsection{Verificaci\'on}
\begin{center}
  \includegraphics[height=7cm]{fourier2}\\
  Figura 6: Error de aproximaci\'on vs n\'umero de t\'erminos.
\end{center}

\newpage

\section{Programa 4: Derivadas totales y parciales}

El Programa 4 implementa el c\'alculo num\'erico de derivadas totales y parciales mediante diferencias finitas, incluyendo derivadas de primer y segundo orden, y derivadas cruzadas.

\subsection{C\'odigo}

\begin{lstlisting}[label={prog4},caption={C\'alculo de derivadas num\'ericas.}]
// 4_derivadas.c
// Calculo de 8 derivadas numericas con validaciones robustas

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <errno.h>

// ============================================================================
// PARAMETROS CONFIGURABLES
// ============================================================================
#define FUNCION_X(x)        (sin(x) + (x)*(x))
#define FUNCION_XY(x,y)     ((x)*(x)*sin(y) + exp((x)*(y)))
#define PUNTO_X0            1.0
#define PUNTO_Y0            0.5
#define PASO_H              0.0001
#define GRAFICO_INICIO      (PUNTO_X0 - 2.0)
#define GRAFICO_FIN         (PUNTO_X0 + 2.0)
#define GRAFICO_PUNTOS      100
#define NOMBRE_GRAFICO      "derivadas_grafico.png"
#define ANCHO_GRAFICO       800
#define ALTO_GRAFICO        600
// ============================================================================

// ============================================================================
// FUNCIONES DE VALIDACION
// ============================================================================
int es_numerico_valido(double valor) {
    return !(isnan(valor) || isinf(valor) || fabs(valor) > 1e100);
}

void verificar_nan_inf(const char *nombre, double valor, int linea) {
    if (isnan(valor)) {
        printf(" ERROR [Linea %d]: %s = NaN (Operacion invalida)\n", linea, nombre);
        printf("   Revise funciones matematicas (division por cero, raiz negativa, etc.)\n");
        exit(EXIT_FAILURE);
    }
    if (isinf(valor)) {
        printf(" ERROR [Linea %d]: %s = Infinito (Overflow)\n", linea, nombre);
        printf("   Valor demasiado grande, reduzca paso h o punto de evaluacion\n");
        exit(EXIT_FAILURE);
    }
    if (!es_numerico_valido(valor)) {
        printf(" ERROR [Linea %d]: %s = Valor numerico invalido\n", linea, nombre);
        exit(EXIT_FAILURE);
    }
}

#define VALIDAR(variable) verificar_nan_inf(#variable, variable, __LINE__)

void validar_parametro_h(double h) {
    if (h <= 0) {
        printf(" ERROR: Paso h debe ser positivo (h = %.6f)\n", h);
        exit(EXIT_FAILURE);
    }
    if (h > 1.0) {
        printf(" ADVERTENCIA: Paso h muy grande (h = %.6f)\n", h);
        printf("   Las derivadas pueden ser imprecisas\n");
    }
    if (h < 1e-10) {
        printf(" ADVERTENCIA: Paso h muy pequeño (h = %.6f)\n", h);
        printf("   Posible error de cancelacion numerica\n");
    }
}

FILE* abrir_archivo(const char *nombre, const char *modo) {
    FILE *archivo = fopen(nombre, modo);
    if (archivo == NULL) {
        printf(" ERROR: No se pudo abrir archivo '%s' (modo: %s)\n", nombre, modo);
        printf("   Codigo de error: %d\n", errno);
        printf("   Verifique permisos y espacio en disco\n");
        exit(EXIT_FAILURE);
    }
    return archivo;
}

void validar_funciones_punto(double x, double y) {
    double fx = FUNCION_X(x);
    double fxy = FUNCION_XY(x, y);
    
    if (!es_numerico_valido(fx)) {
        printf(" ERROR: f(x) invalida en x = %.6f\n", x);
        printf("   f(%.6f) = %.6f\n", x, fx);
        exit(EXIT_FAILURE);
    }
    
    if (!es_numerico_valido(fxy)) {
        printf(" ERROR: f(x,y) invalida en (%.6f, %.6f)\n", x, y);
        printf("   f(%.6f, %.6f) = %.6f\n", x, y, fxy);
        exit(EXIT_FAILURE);
    }
}

// ============================================================================
// FUNCIONES DE CALCULO CON VALIDACION
// ============================================================================
double calcular_derivada_primera(double x0, double h) {
    double f_plus = FUNCION_X(x0 + h);
    double f_minus = FUNCION_X(x0 - h);
    
    VALIDAR(f_plus);
    VALIDAR(f_minus);
    
    // Verificar diferencia significativa
    if (fabs(f_plus - f_minus) < 1e-15) {
        printf(" ADVERTENCIA: Diferencia muy pequeña en derivada primera\n");
        printf("   f(x+h) - f(x-h) = %.2e\n", f_plus - f_minus);
    }
    
    double derivada = (f_plus - f_minus) / (2*h);
    VALIDAR(derivada);
    
    return derivada;
}

double calcular_derivada_segunda(double x0, double h) {
    double f_plus = FUNCION_X(x0 + h);
    double f_center = FUNCION_X(x0);
    double f_minus = FUNCION_X(x0 - h);
    
    VALIDAR(f_plus);
    VALIDAR(f_center);
    VALIDAR(f_minus);
    
    // Verificar valores extremos
    double max_val = fmax(fabs(f_plus), fmax(fabs(f_center), fabs(f_minus)));
    if (max_val > 1e50) {
        printf(" ADVERTENCIA: Valores muy grandes en derivada segunda\n");
    }
    
    double derivada = (f_plus - 2*f_center + f_minus) / (h*h);
    VALIDAR(derivada);
    
    return derivada;
}

double calcular_derivada_parcial_x(double x0, double y0, double h) {
    double f_plus = FUNCION_XY(x0 + h, y0);
    double f_minus = FUNCION_XY(x0 - h, y0);
    
    VALIDAR(f_plus);
    VALIDAR(f_minus);
    
    double derivada = (f_plus - f_minus) / (2*h);
    VALIDAR(derivada);
    
    return derivada;
}

double calcular_derivada_parcial_y(double x0, double y0, double h) {
    double f_plus = FUNCION_XY(x0, y0 + h);
    double f_minus = FUNCION_XY(x0, y0 - h);
    
    VALIDAR(f_plus);
    VALIDAR(f_minus);
    
    double derivada = (f_plus - f_minus) / (2*h);
    VALIDAR(derivada);
    
    return derivada;
}

double calcular_derivada_mixta(double x0, double y0, double h) {
    double f_pp = FUNCION_XY(x0 + h, y0 + h);
    double f_pm = FUNCION_XY(x0 + h, y0 - h);
    double f_mp = FUNCION_XY(x0 - h, y0 + h);
    double f_mm = FUNCION_XY(x0 - h, y0 - h);
    
    VALIDAR(f_pp); VALIDAR(f_pm);
    VALIDAR(f_mp); VALIDAR(f_mm);
    
    // Verificar simetria (para funciones suaves)
    if (fabs(f_pp - f_mm) > 1e-6 * fmax(fabs(f_pp), fabs(f_mm))) {
        printf(" ADVERTENCIA: Asimetria en derivada mixta\n");
        printf("   f(x+h,y+h) - f(x-h,y-h) = %.2e\n", f_pp - f_mm);
    }
    
    double derivada = (f_pp - f_pm - f_mp + f_mm) / (4*h*h);
    VALIDAR(derivada);
    
    return derivada;
}

// ============================================================================
// PROGRAMA PRINCIPAL
// ============================================================================
int main() {
    // ============================================================================
    // VALIDACION INICIAL
    // ============================================================================
    printf(" VALIDANDO PARAMETROS INICIALES...\n");
    printf("-------------------------------------------------------------\n");
    
    validar_parametro_h(PASO_H);
    validar_funciones_punto(PUNTO_X0, PUNTO_Y0);
    
    double h = PASO_H;
    double x0 = PUNTO_X0, y0 = PUNTO_Y0;
    
    // Validar entorno de calculo
    if (!es_numerico_valido(x0) || !es_numerico_valido(y0)) {
        printf(" ERROR: Puntos de evaluacion invalidos\n");
        printf("   x0 = %.6f, y0 = %.6f\n", x0, y0);
        return EXIT_FAILURE;
    }
    
    printf(" Punto de evaluacion valido: (%.6f, %.6f)\n", x0, y0);
    printf(" Paso h valido: %.6f\n", h);
    printf(" Funciones validas en el punto\n\n");
    
    // ============================================================================
    // ENCABEZADO
    // ============================================================================
    printf(" 8 DERIVADAS NUMERICAS CON VALIDACION \n\n");
    
    printf("FUNCIONES:\n");
    printf("  f(x)   = sin(x) + x²\n");
    printf("  f(x,y) = x²·sin(y) + e^(x·y)\n");
    printf("PUNTO:   (x0, y0) = (%.1f, %.1f)\n", x0, y0);
    printf("PASO:    h = %.4f\n\n", h);
    
    // ============================================================================
    // CALCULO DE DERIVADAS CON VALIDACION
    // ============================================================================
    printf(" CALCULANDO DERIVADAS...\n");
    printf("-------------------------------------------------------------\n");
    
    printf("+----+--------------------------------------+-----------------+----------+\n");
    printf("| #  | Derivada                            | Valor Numerico  | Estado   |\n");
    printf("+----+--------------------------------------+-----------------+----------+\n");
    
    // Derivada a) D[f(x), x]
    double da = calcular_derivada_primera(x0, h);
    printf("| a) | D[f(x), x]                          | %14.6f | - VALIDO |\n", da);
    
    // Derivada b) D[f(x), {x, 2}]
    double db = calcular_derivada_segunda(x0, h);
    printf("| b) | D[f(x), {x, 2}]                     | %14.6f | - VALIDO |\n", db);
    
    // Derivada c) D[f(x,y), x]
    double dc = calcular_derivada_parcial_x(x0, y0, h);
    printf("| c) | D[f(x,y), x]                        | %14.6f | - VALIDO |\n", dc);
    
    // Derivada d) D[f(x,y), y]
    double dd = calcular_derivada_parcial_y(x0, y0, h);
    printf("| d) | D[f(x,y), y]                        | %14.6f | - VALIDO |\n", dd);
    
    // Derivada e) D[f(x,y), {x, 2}]
    double de = (FUNCION_XY(x0 + h, y0) - 2*FUNCION_XY(x0, y0) + FUNCION_XY(x0 - h, y0)) / (h*h);
    VALIDAR(de);
    printf("| e) | D[f(x,y), {x, 2}]                   | %14.6f | - VALIDO |\n", de);
    
    // Derivada f) D[f(x,y), {y, 2}]
    double df = (FUNCION_XY(x0, y0 + h) - 2*FUNCION_XY(x0, y0) + FUNCION_XY(x0, y0 - h)) / (h*h);
    VALIDAR(df);
    printf("| f) | D[f(x,y), {y, 2}]                   | %14.6f | - VALIDO |\n", df);
    
    // Derivada g) D[f(x,y), {x, y}]
    double dg = calcular_derivada_mixta(x0, y0, h);
    printf("| g) | D[f(x,y), {x, y}]                   | %14.6f | - VALIDO |\n", dg);
    
    // Derivada h) D[f(x,y), {x, 3}]
    double f_2h = FUNCION_XY(x0 + 2*h, y0);
    double f_h = FUNCION_XY(x0 + h, y0);
    double f_mh = FUNCION_XY(x0 - h, y0);
    double f_m2h = FUNCION_XY(x0 - 2*h, y0);
    
    VALIDAR(f_2h); VALIDAR(f_h);
    VALIDAR(f_mh); VALIDAR(f_m2h);
    
    double dh = (f_2h - 2*f_h + 2*f_mh - f_m2h) / (2*h*h*h);
    VALIDAR(dh);
    printf("| h) | D[f(x,y), {x, 3}]                   | %14.6f | - VALIDO |\n", dh);
    
    printf("+----+--------------------------------------+-----------------+----------+\n");
    
    // ============================================================================
    // GENERAR DATOS PARA GRAFICAS
    // ============================================================================
    printf("\n GENERANDO DATOS PARA GRAFICAS...\n");
    printf("-------------------------------------------------------------\n");
    
    FILE *datos = abrir_archivo("derivadas.dat", "w");
    fprintf(datos, "# x df/dx d^2f/dx^2\n");
    
    double dx_graf = (GRAFICO_FIN - GRAFICO_INICIO) / GRAFICO_PUNTOS;
    int puntos_validos = 0, puntos_invalidos = 0;
    
    for (int i = 0; i <= GRAFICO_PUNTOS; i++) {
        double x = GRAFICO_INICIO + i * dx_graf;
        
        // Calcular derivadas con validacion
        double d1, d2;
        int valido = 1;
        
        try_calc:
        d1 = (FUNCION_X(x + h) - FUNCION_X(x - h)) / (2*h);
        d2 = (FUNCION_X(x + h) - 2*FUNCION_X(x) + FUNCION_X(x - h)) / (h*h);
        
        if (!es_numerico_valido(d1) || !es_numerico_valido(d2)) {
            if (h > 1e-10) {
                // Intentar con h mas grande
                h *= 2;
                printf(" Ajustando h a %.2e para x = %.3f\n", h, x);
                goto try_calc;
            } else {
                puntos_invalidos++;
                valido = 0;
            }
        }
        
        if (valido) {
            fprintf(datos, "%.6f %.6f %.6f\n", x, d1, d2);
            puntos_validos++;
        }
        
        // Progreso
        if (i % (GRAFICO_PUNTOS/10) == 0 && valido) {
            printf("  %3d%%: x=%.3f, f'(x)=%.3f, f''(x)=%.3f\n", 
                   (i*100)/GRAFICO_PUNTOS, x, d1, d2);
        }
    }
    
    fclose(datos);
    
    if (puntos_invalidos > 0) {
        printf(" ADVERTENCIA: %d puntos no pudieron calcularse\n", puntos_invalidos);
        printf("   Se generaron %d puntos validos de %d\n", puntos_validos, GRAFICO_PUNTOS + 1);
    }
    
    // ============================================================================
    // CREAR SCRIPT GNUPLOT
    // ============================================================================
    FILE *script = abrir_archivo("derivadas_plot.gp", "w");
    
    fprintf(script, "# Script para derivadas numericas\n");
    fprintf(script, "set terminal pngcairo size %d,%d enhanced font 'Arial,10'\n", 
            ANCHO_GRAFICO, ALTO_GRAFICO);
    fprintf(script, "set output '%s'\n", NOMBRE_GRAFICO);
    fprintf(script, "set title 'Derivadas de f(x) = sin(x) + x²'\n");
    fprintf(script, "set xlabel 'x'\n");
    fprintf(script, "set ylabel 'Valor de derivada'\n");
    fprintf(script, "set grid\n");
    fprintf(script, "set key top left box\n");
    fprintf(script, "set xrange [%f:%f]\n", GRAFICO_INICIO, GRAFICO_FIN);
    
    fprintf(script, "plot 'derivadas.dat' u 1:2 w l lw 2 lc rgb '#0066CC' title 'Primera derivada f''(x)', \\\n");
    fprintf(script, "     '' u 1:3 w l lw 2 lc rgb '#FF3333' dt 2 title 'Segunda derivada f''''(x)', \\\n");
    fprintf(script, "     %f, %f w p pt 7 ps 2 lc rgb '#00AA00' title 'Punto (x0, %.3f)'\n", 
            x0, da, da);
    
    fclose(script);
    
    // ============================================================================
    // EJECUTAR GNUPLOT
    // ============================================================================
    printf("\n GENERANDO GRAFICO...\n");
    printf("-------------------------------------------------------------\n");
    
    int resultado = system("gnuplot derivadas_plot.gp 2>&1");
    
    if (resultado != 0) {
        printf(" ADVERTENCIA: Gnuplot reporto problemas\n");
        printf("   Comando: gnuplot derivadas_plot.gp\n");
        printf("   Verifique que Gnuplot este instalado correctamente\n");
    } else {
        printf(" Grafico generado: %s\n", NOMBRE_GRAFICO);
    }
    
    // ============================================================================
    // ANALISIS DE ERROR (comparacion analitica)
    // ============================================================================
    printf("\n ANALISIS DE ERROR (comparacion con valores analiticos):\n");
    printf("-------------------------------------------------------------\n");
    
    // Valores analiticos exactos en x0 = 1.0
    double da_analitica = cos(x0) + 2*x0;        // cos(1) + 2
    double db_analitica = -sin(x0) + 2;          // -sin(1) + 2
    
    double error_abs_a = fabs(da - da_analitica);
    double error_rel_a = 100 * error_abs_a / fabs(da_analitica);
    double error_abs_b = fabs(db - db_analitica);
    double error_rel_b = 100 * error_abs_b / fabs(db_analitica);
    
    printf("  Primera derivada (f'(x)):\n");
    printf("    Valor numerico:   %.8f\n", da);
    printf("    Valor analitico:  %.8f\n", da_analitica);
    printf("    Error absoluto:   %.2e\n", error_abs_a);
    printf("    Error relativo:   %.2e%%\n", error_rel_a);
    
    printf("\n  Segunda derivada (f''(x)):\n");
    printf("    Valor numerico:   %.8f\n", db);
    printf("    Valor analitico:  %.8f\n", db_analitica);
    printf("    Error absoluto:   %.2e\n", error_abs_b);
    printf("    Error relativo:   %.2e%%\n", error_rel_b);
    
    // Evaluar calidad de aproximacion
    printf("\n  EVALUACION DE LA APROXIMACION:\n");
    if (error_rel_a < 0.1 && error_rel_b < 0.1) {
        printf("    - Excelente precision (error < 0.1%%)\n");
    } else if (error_rel_a < 1.0 && error_rel_b < 1.0) {
        printf("    - Buena precision (error < 1%%)\n");
    } else if (error_rel_a < 5.0 && error_rel_b < 5.0) {
        printf("    - Precision aceptable (error < 5%%)\n");
    } else {
        printf("    - Precision pobre, considere ajustar h\n");
    }
    
    // ============================================================================
    // RESUMEN FINAL
    // ============================================================================
    printf("\n RESUMEN DE EJECUCION:\n");
    printf("-------------------------------------------------------------\n");
    printf("  Derivadas calculadas:  8/8 exitosas\n");
    printf("  Puntos para grafico:   %d/%d validos\n", puntos_validos, GRAFICO_PUNTOS + 1);
    printf("  Error maximo:          %.2e%%\n", fmax(error_rel_a, error_rel_b));
    printf("  Grafico generado:      %s\n", (resultado == 0) ? "SI" : "NO");
    printf("  Archivos creados:      derivadas.dat, derivadas_plot.gp\n");
    
    printf("\n EJECUCION COMPLETADA\n");
    
    return EXIT_SUCCESS;
}
\end{lstlisting}

\subsection{Gr\'aficos generados por el Programa 4}

La Figura 7 muestra las superficies de la funci\'on y sus derivadas parciales.
\begin{center}
  \includegraphics[height=7cm]{derivadas1}\\
  Figura 7: Funci\'on y sus derivadas parciales.
\end{center}

\subsection{An\'alisis de resultados}
La Figura 7 ilustra la relaci\'on entre la funci\'on original y sus derivadas, mostrando los cambios de pendiente y curvatura.

\subsection{Verificaci\'on}
\begin{center}
  \includegraphics[height=7cm]{derivadas2}\\
  Figura 8: Comparaci\'on con derivadas anal\'iticas.
\end{center}

\newpage

\section{Programa 5: Solución de EDO de primer orden (método de Runge-Kutta)}

El Programa 5 implementa el m\'etodo de Runge-Kutta de cuarto orden para resolver ecuaciones diferenciales ordinarias de primer orden.

\subsection{C\'odigo}

\begin{lstlisting}[label={prog5},caption={M\'etodo de Runge-Kutta para EDO de 1er orden.}]
// 5_ecuacion1.c
// EDO y' = x - y con Runge-Kutta 4 y validaciones robustas

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <errno.h>

// ============================================================================
// PARAMETROS CONFIGURABLES
// ============================================================================
#define EDO_FUNCION(x,y)    ((x) - (y))
#define SOLUCION_EXACTA(x)  ((x) - 1 + 2*exp(-(x)))
#define X_INICIAL           0.0
#define X_FINAL             5.0
#define Y_INICIAL           1.0
#define PASO_H              0.1
#define NOMBRE_GRAFICO      "rk4_grafico.png"
#define ANCHO_GRAFICO       800
#define ALTO_GRAFICO        600
// ============================================================================

// ============================================================================
// FUNCIONES DE VALIDACION
// ============================================================================
int es_numerico_valido(double valor) {
    return !(isnan(valor) || isinf(valor) || fabs(valor) > 1e100);
}

void verificar_nan_inf(const char *nombre, double valor, int linea) {
    if (isnan(valor)) {
        printf(" ERROR [Linea %d]: %s = NaN\n", linea, nombre);
        printf("   Causa posible: Operacion matematica invalida\n");
        exit(EXIT_FAILURE);
    }
    if (isinf(valor)) {
        printf(" ERROR [Linea %d]: %s = Infinito\n", linea, nombre);
        printf("   Causa posible: Overflow numerico\n");
        exit(EXIT_FAILURE);
    }
}

#define VALIDAR(variable) verificar_nan_inf(#variable, variable, __LINE__)

void validar_parametros() {
    if (PASO_H <= 0) {
        printf(" ERROR: PASO_H debe ser positivo (h = %f)\n", PASO_H);
        exit(EXIT_FAILURE);
    }
    
    if (X_FINAL <= X_INICIAL) {
        printf(" ERROR: X_FINAL debe ser > X_INICIAL\n");
        printf("   X_INICIAL = %f, X_FINAL = %f\n", X_INICIAL, X_FINAL);
        exit(EXIT_FAILURE);
    }
    
    if (!es_numerico_valido(Y_INICIAL)) {
        printf(" ERROR: Y_INICIAL invalido: %f\n", Y_INICIAL);
        exit(EXIT_FAILURE);
    }
    
    // Validar solucion exacta en algunos puntos
    for (double x = X_INICIAL; x <= X_FINAL; x += 1.0) {
        double y_exacta = SOLUCION_EXACTA(x);
        if (!es_numerico_valido(y_exacta)) {
            printf(" ERROR: Solucion exacta invalida en x = %f\n", x);
            exit(EXIT_FAILURE);
        }
    }
}

FILE* abrir_archivo(const char *nombre, const char *modo) {
    FILE *archivo = fopen(nombre, modo);
    if (archivo == NULL) {
        printf(" ERROR: No se pudo abrir '%s'\n", nombre);
        printf("   Error del sistema: %d\n", errno);
        exit(EXIT_FAILURE);
    }
    return archivo;
}

// ============================================================================
// RUNGE-KUTTA 4 CON VALIDACION
// ============================================================================
double rk4_validado(double x, double y, double h, int paso_actual) {
    double k1, k2, k3, k4;
    
    // k1
    k1 = EDO_FUNCION(x, y);
    VALIDAR(k1);
    
    // k2
    double x2 = x + h/2;
    double y2 = y + h*k1/2;
    VALIDAR(x2); VALIDAR(y2);
    
    k2 = EDO_FUNCION(x2, y2);
    VALIDAR(k2);
    
    // k3
    double x3 = x + h/2;
    double y3 = y + h*k2/2;
    VALIDAR(x3); VALIDAR(y3);
    
    k3 = EDO_FUNCION(x3, y3);
    VALIDAR(k3);
    
    // k4
    double x4 = x + h;
    double y4 = y + h*k3;
    VALIDAR(x4); VALIDAR(y4);
    
    k4 = EDO_FUNCION(x4, y4);
    VALIDAR(k4);
    
    // Resultado final
    double resultado = y + h*(k1 + 2*k2 + 2*k3 + k4)/6;
    VALIDAR(resultado);
    
    // Detectar inestabilidad
    if (fabs(resultado) > 1e10 && paso_actual > 10) {
        printf(" ADVERTENCIA [Paso %d]: Posible inestabilidad numerica\n", paso_actual);
        printf("   y = %.2e, puede haber divergencia\n", resultado);
    }
    
    return resultado;
}

// ============================================================================
// PROGRAMA PRINCIPAL
// ============================================================================
int main() {
    // ============================================================================
    // VALIDACION INICIAL
    // ============================================================================
    printf(" VALIDANDO PARAMETROS...\n");
    printf("-------------------------------------------------------------\n");
    
    validar_parametros();
    
    double x = X_INICIAL;
    double y = Y_INICIAL;
    int paso = 0;
    int pasos_totales = (int)((X_FINAL - X_INICIAL) / PASO_H) + 1;
    
    printf(" Parametros validos\n");
    printf("   Ecuacion: y' = x - y\n");
    printf("   Condicion inicial: y(%.1f) = %.1f\n", X_INICIAL, Y_INICIAL);
    printf("   Intervalo: [%.1f, %.1f]\n", X_INICIAL, X_FINAL);
    printf("   Paso: h = %.3f\n", PASO_H);
    printf("   Pasos estimados: %d\n\n", pasos_totales);
    
    // ============================================================================
    // CONFIGURACION
    // ============================================================================
    printf(" ECUACION DIFERENCIAL: y' = x - y (RK4) \n\n");
    
    FILE *datos_sol = abrir_archivo("rk4_solucion.dat", "w");
    FILE *datos_err = abrir_archivo("rk4_error.dat", "w");
    FILE *script_gp = abrir_archivo("rk4_plot.gp", "w");
    
    printf("PROCESO DE INTEGRACION:\n");
    printf("+------+--------+-----------+-----------+-----------+-----------+\n");
    printf("| Paso |   x    |   y_RK4   | y_Exacta  |  Error    | Estado    |\n");
    printf("+------+--------+-----------+-----------+-----------+-----------+\n");
    
    int errores_numericos = 0;
    double error_maximo = 0.0;
    
    // ============================================================================
    // INTEGRACION CON RUNGE-KUTTA 4
    // ============================================================================
    while (x <= X_FINAL + PASO_H/2) {
        // Calcular solucion exacta
        double exacta = SOLUCION_EXACTA(x);
        VALIDAR(exacta);
        
        double error = fabs(y - exacta);
        VALIDAR(error);
        
        if (error > error_maximo) {
            error_maximo = error;
        }
        
        // Estado de validacion
        const char *estado = "- OK";
        if (!es_numerico_valido(y)) {
            estado = "- INVALIDO";
            errores_numericos++;
            
            printf("+------+--------+-----------+-----------+-----------+-----------+\n");
            printf("| %4d | %6.2f | %9.5f | %9.5f | %9.5f | %s |\n", 
                   paso, x, y, exacta, error, estado);
            printf("+------+--------+-----------+-----------+-----------+-----------+\n");
            
            printf("\n ERROR CRITICO: Valor no numerico en paso %d\n", paso);
            printf("   x = %.6f, y = %.6f\n", x, y);
            printf("   El metodo no puede continuar\n");
            
            fclose(datos_sol);
            fclose(datos_err);
            return EXIT_FAILURE;
        }
        
        // Mostrar cada 5 pasos
        if (paso % 5 == 0) {
            printf("| %4d | %6.2f | %9.5f | %9.5f | %9.5f | %s |\n", 
                   paso, x, y, exacta, error, estado);
        }
        
        // Guardar datos
        fprintf(datos_sol, "%.6f %.6f\n", x, y);
        fprintf(datos_err, "%.6f %.6f\n", x, error);
        
        // Ultimo punto
        if (x >= X_FINAL) break;
        
        // Calcular siguiente punto
        double y_nuevo = rk4_validado(x, y, PASO_H, paso);
        
        // Validar nuevo valor
        if (!es_numerico_valido(y_nuevo)) {
            printf(" ADVERTENCIA: Valor invalido en paso %d, ajustando...\n", paso);
            
            // Intentar con paso mas pequeño
            double y_half1 = rk4_validado(x, y, PASO_H/2, paso);
            double y_half2 = rk4_validado(x + PASO_H/2, y_half1, PASO_H/2, paso);
            
            if (es_numerico_valido(y_half2)) {
                y_nuevo = y_half2;
                printf("   Solucionado con paso reducido a h/2\n");
            } else {
                printf(" ERROR: No se pudo recuperar con paso reducido\n");
                break;
            }
        }
        
        y = y_nuevo;
        x += PASO_H;
        paso++;
        
        // Verificar limite de pasos (prevencion de bucle infinito)
        if (paso > pasos_totales * 10) {
            printf(" ADVERTENCIA: Demasiados pasos (%d), posible bucle infinito\n", paso);
            break;
        }
    }
    
    printf("+------+--------+-----------+-----------+-----------+-----------+\n");
    printf("| INTEGRACION COMPLETADA: %d pasos, %d errores numericos      |\n", 
           paso, errores_numericos);
    printf("+--------------------------------------------------------------+\n\n");
    
    fclose(datos_sol);
    fclose(datos_err);
    
    // ============================================================================
    // CREAR SCRIPT GNUPLOT
    // ============================================================================
    fprintf(script_gp, "# Script para Runge-Kutta 4\n");
    fprintf(script_gp, "set terminal pngcairo size %d,%d enhanced font 'Arial,10'\n", 
            ANCHO_GRAFICO, ALTO_GRAFICO);
    fprintf(script_gp, "set output '%s'\n", NOMBRE_GRAFICO);
    fprintf(script_gp, "set title 'Metodo de Runge-Kutta 4: y' = x - y'\n");
    fprintf(script_gp, "set xlabel 'x'\n");
    fprintf(script_gp, "set ylabel 'y(x)'\n");
    fprintf(script_gp, "set grid\n");
    fprintf(script_gp, "set key top left box\n");
    fprintf(script_gp, "set xrange [%f:%f]\n", X_INICIAL, X_FINAL);
    
    fprintf(script_gp, "plot 'rk4_solucion.dat' w lp pt 7 ps 0.5 lc rgb '#0066CC' title 'Solucion RK4', \\\n");
    fprintf(script_gp, "     x - 1 + 2*exp(-x) w l lw 2 lc rgb '#FF3333' title 'Solucion exacta', \\\n");
    fprintf(script_gp, "     'rk4_error.dat' u 1:2 w l lw 1 lc rgb '#00AA00' axes x1y2 title 'Error'\n");
    
    fprintf(script_gp, "\n# Configurar segundo eje Y para error\n");
    fprintf(script_gp, "set y2tics\n");
    fprintf(script_gp, "set y2label 'Error absoluto'\n");
    
    fclose(script_gp);
    
    // ============================================================================
    // EJECUTAR GNUPLOT
    // ============================================================================
    printf(" GENERANDO GRAFICO...\n");
    printf("-------------------------------------------------------------\n");
    
    int resultado_gnuplot = system("gnuplot rk4_plot.gp 2>&1");
    
    if (resultado_gnuplot != 0) {
        printf(" ADVERTENCIA: Gnuplot reporto problemas\n");
        printf("   Comando: gnuplot rk4_plot.gp\n");
    } else {
        printf(" Grafico generado: %s\n", NOMBRE_GRAFICO);
    }
    
    // ============================================================================
    // ANALISIS DE RESULTADOS
    // ============================================================================
    printf("\n ANALISIS DE RESULTADOS:\n");
    printf("-------------------------------------------------------------\n");
    
    // Calcular estadisticas de error
    FILE *err_file = fopen("rk4_error.dat", "r");
    double error_promedio = 0.0;
    double error_final = 0.0;
    int puntos_leidos = 0;
    double x_val, err_val;
    
    if (err_file) {
        while (fscanf(err_file, "%lf %lf", &x_val, &err_val) == 2) {
            error_promedio += err_val;
            if (x_val == X_FINAL || puntos_leidos == paso - 1) {
                error_final = err_val;
            }
            puntos_leidos++;
        }
        fclose(err_file);
        
        if (puntos_leidos > 0) {
            error_promedio /= puntos_leidos;
        }
    }
    
    printf("  Pasos completados:   %d de %d estimados\n", paso, pasos_totales);
    printf("  Error maximo:        %.6f\n", error_maximo);
    printf("  Error promedio:      %.6f\n", error_promedio);
    printf("  Error final:         %.6f\n", error_final);
    printf("  Errores numericos:   %d\n", errores_numericos);
    
    // Evaluar precision
    printf("\n  EVALUACION DE PRECISION:\n");
    if (error_maximo < 0.001) {
        printf("    - Excelente precision (error maximo < 0.001)\n");
    } else if (error_maximo < 0.01) {
        printf("    - Buena precision (error maximo < 0.01)\n");
    } else if (error_maximo < 0.1) {
        printf("    - Precision aceptable (error maximo < 0.1)\n");
    } else {
        printf("    - Precision pobre, considere reducir el paso h\n");
    }
    
    // ============================================================================
    // VALIDACION FINAL DE CONSERVACION
    // ============================================================================
    printf("\n VALIDACION DE CONSERVACION:\n");
    printf("-------------------------------------------------------------\n");
    
    // Calcular derivada numerica final
    double derivada_final = EDO_FUNCION(X_FINAL, y);
    double derivada_teorica = X_FINAL - y;
    double discrepancia = fabs(derivada_final - derivada_teorica);
    
    printf("  En x = %.2f:\n", X_FINAL);
    printf("    y calculado:     %.6f\n", y);
    printf("    y exacto:        %.6f\n", SOLUCION_EXACTA(X_FINAL));
    printf("    y' calculado:    %.6f\n", derivada_final);
    printf("    y' teorico:      %.6f\n", derivada_teorica);
    printf("    Discrepancia:    %.2e\n", discrepancia);
    
    if (discrepancia > 0.01) {
        printf("  ADVERTENCIA: Discrepancia significativa en derivada\n");
    }
    
    // ============================================================================
    // RESUMEN FINAL
    // ============================================================================
    printf("\n RESUMEN DE EJECUCION:\n");
    printf("-------------------------------------------------------------\n");
    printf("  Estado:              %s\n", 
           (errores_numericos == 0) ? "EXITOSO" : "CON ADVERTENCIAS");
    printf("  Pasos ejecutados:    %d\n", paso);
    printf("  Error maximo:        %.2e\n", error_maximo);
    printf("  Grafico generado:    %s\n", 
           (resultado_gnuplot == 0) ? "SI" : "NO");
    printf("  Archivos creados:    rk4_solucion.dat, rk4_error.dat, rk4_plot.gp\n");
    
    printf("\n EJECUCION COMPLETADA\n");
    
    return (errores_numericos == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
}
\end{lstlisting}

\subsection{Gr\'aficos generados por el Programa 5}

La Figura 9 muestra la soluci\'on num\'erica de la EDO comparada con la soluci\'on anal\'itica cuando es posible.
\begin{center}
  \includegraphics[height=7cm]{rk1_1}\\
  Figura 9: Soluci\'on de EDO de primer orden.
\end{center}

\subsection{An\'alisis de resultados}
La Figura 9 presenta la precisi\'on del m\'etodo de Runge-Kutta para diferentes tamaños de paso.

\subsection{Verificaci\'on}
\begin{center}
  \includegraphics[height=7cm]{rk1_2}\\
  Figura 10: Error global del m\'etodo.
\end{center}

\newpage

\section{Programa 6: Solución de EDO de segundo orden (método de Runge-Kutta)}

El Programa 6 extiende el m\'etodo de Runge-Kutta para resolver ecuaciones diferenciales ordinarias de segundo orden, transform\'andolas en sistemas de primer orden.

\subsection{C\'odigo}

\begin{lstlisting}[label={prog6},caption={M\'etodo de Runge-Kutta para EDO de 2do orden.}]
// 6_ecuacion2.c
// EDO y'' + y = 0 con Runge-Kutta 4 y validaciones robustas

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <errno.h>

// ============================================================================
// PARAMETROS CONFIGURABLES
// ============================================================================
#define EDO_FUNCION(x,y,yp) (-(y))
#define SOLUCION_EXACTA(x)  (sin(x))
#define X_INICIAL           0.0
#define X_FINAL             4*M_PI
#define Y_INICIAL           0.0
#define YP_INICIAL          1.0
#define PASO_H              0.05
#define NOMBRE_GRAFICO      "ypp_grafico.png"
#define ANCHO_GRAFICO       800
#define ALTO_GRAFICO        1000
// ============================================================================

// ============================================================================
// FUNCIONES DE VALIDACION
// ============================================================================
int es_numerico_valido(double valor) {
    return !(isnan(valor) || isinf(valor) || fabs(valor) > 1e100);
}

void verificar_nan_inf(const char *nombre, double valor, int linea) {
    if (isnan(valor)) {
        printf(" ERROR [Linea %d]: %s = NaN\n", linea, nombre);
        printf("   Posible causa: Division por cero o operacion invalida\n");
        exit(EXIT_FAILURE);
    }
    if (isinf(valor)) {
        printf(" ERROR [Linea %d]: %s = Infinito\n", linea, nombre);
        printf("   Posible causa: Overflow numerico\n");
        exit(EXIT_FAILURE);
    }
}

#define VALIDAR(variable) verificar_nan_inf(#variable, variable, __LINE__)

void validar_parametros() {
    if (PASO_H <= 0) {
        printf(" ERROR: PASO_H debe ser positivo (h = %f)\n", PASO_H);
        exit(EXIT_FAILURE);
    }
    
    if (X_FINAL <= X_INICIAL) {
        printf(" ERROR: X_FINAL debe ser > X_INICIAL\n");
        exit(EXIT_FAILURE);
    }
    
    if (!es_numerico_valido(Y_INICIAL) || !es_numerico_valido(YP_INICIAL)) {
        printf(" ERROR: Condiciones iniciales invalidas\n");
        printf("   y(0) = %f, y'(0) = %f\n", Y_INICIAL, YP_INICIAL);
        exit(EXIT_FAILURE);
    }
    
    // Validar periodicidad esperada
    if (fabs(X_FINAL - 4*M_PI) > 1e-10) {
        printf(" ADVERTENCIA: X_FINAL no es multiplo exacto de π\n");
        printf("   Para solucion periodica, use X_FINAL = n*π\n");
    }
}

FILE* abrir_archivo(const char *nombre, const char *modo) {
    FILE *archivo = fopen(nombre, modo);
    if (archivo == NULL) {
        printf(" ERROR: No se pudo abrir '%s'\n", nombre);
        printf("   Error del sistema: %d\n", errno);
        exit(EXIT_FAILURE);
    }
    return archivo;
}

// ============================================================================
// RUNGE-KUTTA 4 PARA SISTEMAS CON VALIDACION
// ============================================================================
void rk4_sistema_validado(double x, double *y, double *yp, double h, int paso_actual) {
    double k1_y, k1_yp, k2_y, k2_yp, k3_y, k3_yp, k4_y, k4_yp;
    
    // k1
    k1_y = *yp;
    k1_yp = EDO_FUNCION(x, *y, *yp);
    VALIDAR(k1_y); VALIDAR(k1_yp);
    
    // k2
    double x2 = x + h/2;
    double y2 = *y + h*k1_y/2;
    double yp2 = *yp + h*k1_yp/2;
    VALIDAR(x2); VALIDAR(y2); VALIDAR(yp2);
    
    k2_y = yp2;
    k2_yp = EDO_FUNCION(x2, y2, yp2);
    VALIDAR(k2_y); VALIDAR(k2_yp);
    
    // k3
    double x3 = x + h/2;
    double y3 = *y + h*k2_y/2;
    double yp3 = *yp + h*k2_yp/2;
    VALIDAR(x3); VALIDAR(y3); VALIDAR(yp3);
    
    k3_y = yp3;
    k3_yp = EDO_FUNCION(x3, y3, yp3);
    VALIDAR(k3_y); VALIDAR(k3_yp);
    
    // k4
    double x4 = x + h;
    double y4 = *y + h*k3_y;
    double yp4 = *yp + h*k3_yp;
    VALIDAR(x4); VALIDAR(y4); VALIDAR(yp4);
    
    k4_y = yp4;
    k4_yp = EDO_FUNCION(x4, y4, yp4);
    VALIDAR(k4_y); VALIDAR(k4_yp);
    
    // Actualizar valores
    double y_nuevo = *y + h*(k1_y + 2*k2_y + 2*k3_y + k4_y)/6;
    double yp_nuevo = *yp + h*(k1_yp + 2*k2_yp + 2*k3_yp + k4_yp)/6;
    
    VALIDAR(y_nuevo); VALIDAR(yp_nuevo);
    
    // Verificar conservacion de energia (E = y² + y'²)
    double energia_antes = (*y)*(*y) + (*yp)*(*yp);
    double energia_despues = y_nuevo*y_nuevo + yp_nuevo*yp_nuevo;
    double delta_energia = fabs(energia_despues - energia_antes);
    
    if (delta_energia > 0.01 && paso_actual > 10) {
        printf(" ADVERTENCIA [Paso %d]: Energia no se conserva bien\n", paso_actual);
        printf("   ΔE = %.2e (deberia ser ~0)\n", delta_energia);
    }
    
    // Verificar crecimiento exponencial (indicador de inestabilidad)
    if (fabs(y_nuevo) > 10*fabs(*y) && paso_actual > 5) {
        printf(" ADVERTENCIA [Paso %d]: Posible inestabilidad\n", paso_actual);
        printf("   y crecio de %.2e a %.2e\n", *y, y_nuevo);
    }
    
    *y = y_nuevo;
    *yp = yp_nuevo;
}

// ============================================================================
// PROGRAMA PRINCIPAL
// ============================================================================
int main() {
    // ============================================================================
    // VALIDACION INICIAL
    // ============================================================================
    printf(" VALIDANDO PARAMETROS...\n");
    printf("-------------------------------------------------------------\n");
    
    validar_parametros();
    
    double x = X_INICIAL;
    double y = Y_INICIAL;
    double yp = YP_INICIAL;
    int paso = 0;
    int pasos_totales = (int)((X_FINAL - X_INICIAL) / PASO_H) + 1;
    
    printf(" Parametros validos\n");
    printf("   Ecuacion: y'' + y = 0\n");
    printf("   Condiciones: y(0) = %.1f, y'(0) = %.1f\n", Y_INICIAL, YP_INICIAL);
    printf("   Intervalo: [%.1f, %.1f]\n", X_INICIAL, X_FINAL);
    printf("   Paso: h = %.3f\n", PASO_H);
    printf("   Pasos estimados: %d\n\n", pasos_totales);
    
    // ============================================================================
    // CONFIGURACION
    // ============================================================================
    printf(" ECUACION DIFERENCIAL: y'' + y = 0 (RK4) \n\n");
    
    FILE *datos_sol = abrir_archivo("ypp_solucion.dat", "w");
    FILE *datos_der = abrir_archivo("ypp_derivada.dat", "w");
    FILE *datos_fase = abrir_archivo("ypp_fase.dat", "w");
    FILE *script_gp = abrir_archivo("ypp_plot.gp", "w");
    
    printf("PROCESO DE INTEGRACION:\n");
    printf("+------+--------+-----------+-----------+-----------+-----------+\n");
    printf("| Paso |   x    |   y(x)    |   y'(x)   |  Error    |  Energia  |\n");
    printf("+------+--------+-----------+-----------+-----------+-----------+\n");
    
    int errores_numericos = 0;
    double error_maximo = 0.0;
    double energia_inicial = Y_INICIAL*Y_INICIAL + YP_INICIAL*YP_INICIAL;
    
    // ============================================================================
    // INTEGRACION CON RUNGE-KUTTA 4
    // ============================================================================
    while (x <= X_FINAL + PASO_H/2) {
        // Calcular solucion exacta y error
        double exacta = SOLUCION_EXACTA(x);
        VALIDAR(exacta);
        
        double error = fabs(y - exacta);
        VALIDAR(error);
        
        if (error > error_maximo) {
            error_maximo = error;
        }
        
        // Calcular energia actual
        double energia_actual = y*y + yp*yp;
        VALIDAR(energia_actual);
        
        // Estado de validacion
        const char *estado = "- OK";
        if (!es_numerico_valido(y) || !es_numerico_valido(yp)) {
            estado = "- INVALIDO";
            errores_numericos++;
            
            printf("+------+--------+-----------+-----------+-----------+-----------+\n");
            printf("| %4d | %6.3f | %9.5f | %9.5f | %9.5f | %9.5f | %s |\n", 
                   paso, x, y, yp, error, energia_actual, estado);
            printf("+------+--------+-----------+-----------+-----------+-----------+\n");
            
            printf("\n ERROR CRITICO: Valores no numericos en paso %d\n", paso);
            printf("   x = %.6f, y = %.6f, y' = %.6f\n", x, y, yp);
            
            fclose(datos_sol);
            fclose(datos_der);
            fclose(datos_fase);
            return EXIT_FAILURE;
        }
        
        // Mostrar cada 20 pasos
        if (paso % 20 == 0) {
            printf("| %4d | %6.3f | %9.5f | %9.5f | %9.5f | %9.5f | %s |\n", 
                   paso, x, y, yp, error, energia_actual, estado);
        }
        
        // Guardar datos
        fprintf(datos_sol, "%.6f %.6f\n", x, y);
        fprintf(datos_der, "%.6f %.6f\n", x, yp);
        fprintf(datos_fase, "%.6f %.6f\n", y, yp);
        
        // Ultimo punto
        if (x >= X_FINAL) break;
        
        // Calcular siguiente punto
        rk4_sistema_validado(x, &y, &yp, PASO_H, paso);
        
        x += PASO_H;
        paso++;
        
        // Verificar limite de pasos
        if (paso > pasos_totales * 10) {
            printf(" ADVERTENCIA: Demasiados pasos (%d)\n", paso);
            break;
        }
    }
    
    printf("+------+--------+-----------+-----------+-----------+-----------+\n");
    printf("| INTEGRACION COMPLETADA: %d pasos                            |\n", paso);
    printf("+--------------------------------------------------------------+\n\n");
    
    fclose(datos_sol);
    fclose(datos_der);
    fclose(datos_fase);
    
    // ============================================================================
    // CREAR SCRIPT GNUPLOT
    // ============================================================================
    fprintf(script_gp, "# Script para ecuacion y'' + y = 0\n");
    fprintf(script_gp, "set terminal pngcairo size %d,%d enhanced font 'Arial,10'\n", 
            ANCHO_GRAFICO, ALTO_GRAFICO);
    fprintf(script_gp, "set output '%s'\n", NOMBRE_GRAFICO);
    
    fprintf(script_gp, "\n# Configurar multiples graficos\n");
    fprintf(script_gp, "set multiplot layout 2,1\n");
    fprintf(script_gp, "set lmargin 10\n");
    fprintf(script_gp, "set rmargin 5\n\n");
    
    // Grafico 1: Solucion
    fprintf(script_gp, "# Grafico 1: Solucion y(x)\n");
    fprintf(script_gp, "set title 'Solucion: y'' + y = 0'\n");
    fprintf(script_gp, "set xlabel 'x'\n");
    fprintf(script_gp, "set ylabel 'y(x)'\n");
    fprintf(script_gp, "set grid\n");
    fprintf(script_gp, "set key top left box\n");
    fprintf(script_gp, "plot 'ypp_solucion.dat' w l lw 2 lc rgb '#0066CC' title 'Solucion RK4', \\\n");
    fprintf(script_gp, "     sin(x) w l lw 2 lc rgb '#FF3333' dt 2 title 'sin(x) (exacta)'\n\n");
    
    // Grafico 2: Plano de fase
    fprintf(script_gp, "# Grafico 2: Plano de fase\n");
    fprintf(script_gp, "set title 'Plano de fase: y vs y''\n");
    fprintf(script_gp, "set xlabel 'y(x)'\n");
    fprintf(script_gp, "set ylabel 'y'(x)'\n");
    fprintf(script_gp, "set grid\n");
    fprintf(script_gp, "set key off\n");
    fprintf(script_gp, "set size ratio -1\n");
    fprintf(script_gp, "plot 'ypp_fase.dat' w l lw 1.5 lc rgb '#00AA00' title 'Trayectoria'\n\n");
    
    fprintf(script_gp, "unset multiplot\n");
    fclose(script_gp);
    
    // ============================================================================
    // EJECUTAR GNUPLOT
    // ============================================================================
    printf(" GENERANDO GRAFICO...\n");
    printf("-------------------------------------------------------------\n");
    
    int resultado_gnuplot = system("gnuplot ypp_plot.gp 2>&1");
    
    if (resultado_gnuplot != 0) {
        printf(" ADVERTENCIA: Gnuplot reporto problemas\n");
    } else {
        printf(" Grafico generado: %s\n", NOMBRE_GRAFICO);
    }
    
    // ============================================================================
    // ANALISIS DE RESULTADOS
    // ============================================================================
    printf("\n ANALISIS DE RESULTADOS:\n");
    printf("-------------------------------------------------------------\n");
    
    // Calcular energia final y variacion
    double energia_final = y*y + yp*yp;
    double variacion_energia = fabs(energia_final - energia_inicial);
    double variacion_relativa = 100 * variacion_energia / energia_inicial;
    
    // Calcular periodicidad
    double periodo_teorico = 2*M_PI;
    int ciclos_completos = (int)(X_FINAL / periodo_teorico);
    
    printf("  Pasos completados:   %d\n", paso);
    printf("  Error maximo:        %.6f\n", error_maximo);
    printf("  Energia inicial:     %.6f\n", energia_inicial);
    printf("  Energia final:       %.6f\n", energia_final);
    printf("  Variacion energia:   %.2e (%.2f%%)\n", 
           variacion_energia, variacion_relativa);
    printf("  Ciclos completos:    %d\n", ciclos_completos);
    printf("  Errores numericos:   %d\n", errores_numericos);
    
    // Evaluar conservacion de energia
    printf("\n  EVALUACION DE CONSERVACION DE ENERGIA:\n");
    if (variacion_relativa < 0.1) {
        printf("    - Excelente conservacion (ΔE < 0.1%%)\n");
    } else if (variacion_relativa < 1.0) {
        printf("    - Buena conservacion (ΔE < 1%%)\n");
    } else if (variacion_relativa < 5.0) {
        printf("    - Conservacion aceptable (ΔE < 5%%)\n");
    } else {
        printf("    - Mala conservacion, metodo puede ser inestable\n");
    }
    
    // Evaluar periodicidad
    printf("\n  EVALUACION DE PERIODICIDAD:\n");
    double y_final_teorico = sin(X_FINAL);
    double error_periodicidad = fabs(y - y_final_teorico);
    
    if (error_periodicidad < 0.01) {
        printf("    - Buena periodicidad (error < 0.01)\n");
    } else if (error_periodicidad < 0.1) {
        printf("    - Periodicidad aceptable (error < 0.1)\n");
    } else {
        printf("    - Periodicidad pobre, posible acumulacion de error\n");
    }
    
    // ============================================================================
    // VALIDACION DE PROPIEDADES MATEMATICAS
    // ============================================================================
    printf("\n VALIDACION DE PROPIEDADES MATEMATICAS:\n");
    printf("-------------------------------------------------------------\n");
    
    // Verificar que satisface la EDO
    double ypp_numerica = EDO_FUNCION(x, y, yp);
    double residual = ypp_numerica + y;  // y'' + y deberia ser 0
    
    printf("  En x = %.4f:\n", x);
    printf("    y calculado:       %.8f\n", y);
    printf("    y' calculado:      %.8f\n", yp);
    printf("    y'' calculado:     %.8f\n", ypp_numerica);
    printf("    Residual (y''+y):  %.2e (deberia ser ~0)\n", residual);
    
    if (fabs(residual) > 0.1) {
        printf("  ADVERTENCIA: Residual grande, solucion puede no satisfacer EDO\n");
    }
    
    // ============================================================================
    // RESUMEN FINAL
    // ============================================================================
    printf("\n RESUMEN DE EJECUCION:\n");
    printf("-------------------------------------------------------------\n");
    printf("  Estado:              %s\n", 
           (errores_numericos == 0) ? "EXITOSO" : "CON ADVERTENCIAS");
    printf("  Pasos ejecutados:    %d\n", paso);
    printf("  Error maximo:        %.2e\n", error_maximo);
    printf("  ΔEnergia:            %.2e (%.2f%%)\n", 
           variacion_energia, variacion_relativa);
    printf("  Grafico generado:    %s\n", 
           (resultado_gnuplot == 0) ? "SI" : "NO");
    printf("  Archivos creados:    ypp_solucion.dat, ypp_derivada.dat, ypp_fase.dat\n");
    
    printf("\n EJECUCION COMPLETADA\n");
    
    return (errores_numericos == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
}
\end{lstlisting}

\subsection{Gr\'aficos generados por el Programa 6}

La Figura 11 muestra la soluci\'on de una EDO de segundo orden t\'ipica como el oscilador arm\'onico.
\begin{center}
  \includegraphics[height=7cm]{rk2_1}\\
  Figura 11: Soluci\'on de EDO de segundo orden.
\end{center}

\subsection{An\'alisis de resultados}
La Figura 11 ilustra el comportamiento oscilatorio y la conservaci\'on de energ\'ia en el sistema.

\subsection{Verificaci\'on}
\begin{center}
  \includegraphics[height=7cm]{rk2_2}\\
  Figura 12: Conservaci\'on de la energ\'ia total.
\end{center}

\newpage

\section{Programa 7: Sistema de ecuaciones diferenciales (Runge-Kutta para x(t) y y(t))}

El Programa 7 implementa el m\'etodo de Runge-Kutta para resolver sistemas de ecuaciones diferenciales acopladas, como los modelos depredador-presa o sistemas mec\'anicos.

\subsection{C\'odigo}

\begin{lstlisting}[label={prog7},caption={Runge-Kutta para sistema de EDOs.}]
/// 7_sistema_edos.c
// Sistema dx/dt = y, dy/dt = -x con validaciones robustas

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <errno.h>

// ============================================================================
// ============================================================================
#define F1(x,y)             (y)
#define F2(x,y)             (-(x))
#define T_INICIAL           0.0
#define T_FINAL             10.0
#define X_INICIAL           1.0
#define Y_INICIAL           0.0
#define PASO_H              0.05
#define NOMBRE_GRAFICO1     "sistema_temporal.png"
#define NOMBRE_GRAFICO2     "sistema_fase.png"
#define ANCHO_GRAFICO       800
#define ALTO_GRAFICO        600
// ============================================================================

// ============================================================================
// FUNCIONES DE VALIDACION
// ============================================================================
int es_numerico_valido(double valor) {
    return !(isnan(valor) || isinf(valor) || fabs(valor) > 1e100);
}

void verificar_nan_inf(const char *nombre, double valor, int linea) {
    if (isnan(valor)) {
        printf("ERROR [Linea %d]: %s = NaN\n", linea, nombre);
        printf("   Causa: Operacion matematica invalida\n");
        exit(EXIT_FAILURE);
    }
    if (isinf(valor)) {
        printf("ERROR [Linea %d]: %s = Infinito\n", linea, nombre);
        printf("   Causa: Overflow numerico\n");
        exit(EXIT_FAILURE);
    }
}

#define VALIDAR(variable) verificar_nan_inf(#variable, variable, __LINE__)

void validar_parametros() {
    if (PASO_H <= 0) {
        printf("ERROR: PASO_H debe ser positivo (h = %f)\n", PASO_H);
        exit(EXIT_FAILURE);
    }
    
    if (T_FINAL <= T_INICIAL) {
        printf("ERROR: T_FINAL debe ser > T_INICIAL\n");
        exit(EXIT_FAILURE);
    }
    
    if (!es_numerico_valido(X_INICIAL) || !es_numerico_valido(Y_INICIAL)) {
        printf("ERROR: Condiciones iniciales invalidas\n");
        exit(EXIT_FAILURE);
    }
    
    // Verificar propiedades del sistema
    double f1_inicial = F1(X_INICIAL, Y_INICIAL);
    double f2_inicial = F2(X_INICIAL, Y_INICIAL);
    VALIDAR(f1_inicial);
    VALIDAR(f2_inicial);
    
    // Sistema lineal: matriz antisimetrica -> energia constante
    printf("Sistema valido: matriz antisimetrica\n");
}

FILE* abrir_archivo(const char *nombre, const char *modo) {
    FILE *archivo = fopen(nombre, modo);
    if (archivo == NULL) {
        printf("ERROR: No se pudo abrir '%s'\n", nombre);
        exit(EXIT_FAILURE);
    }
    return archivo;
}

// ============================================================================
// RUNGE-KUTTA 4 PARA SISTEMAS 2x2 CON VALIDACION
// ============================================================================
void rk4_sistema2_validado(double t, double *x, double *y, double h, int iter_actual) {
    double k1_x, k1_y, k2_x, k2_y, k3_x, k3_y, k4_x, k4_y;
    
    // k1
    k1_x = F1(*x, *y);
    k1_y = F2(*x, *y);
    VALIDAR(k1_x); VALIDAR(k1_y);
    
    // k2
    double x2 = *x + h*k1_x/2;
    double y2 = *y + h*k1_y/2;
    VALIDAR(x2); VALIDAR(y2);
    
    k2_x = F1(x2, y2);
    k2_y = F2(x2, y2);
    VALIDAR(k2_x); VALIDAR(k2_y);
    
    // k3
    double x3 = *x + h*k2_x/2;
    double y3 = *y + h*k2_y/2;
    VALIDAR(x3); VALIDAR(y3);
    
    k3_x = F1(x3, y3);
    k3_y = F2(x3, y3);
    VALIDAR(k3_x); VALIDAR(k3_y);
    
    // k4
    double x4 = *x + h*k3_x;
    double y4 = *y + h*k3_y;
    VALIDAR(x4); VALIDAR(y4);
    
    k4_x = F1(x4, y4);
    k4_y = F2(x4, y4);
    VALIDAR(k4_x); VALIDAR(k4_y);
    
    // Nuevos valores
    double x_nuevo = *x + h*(k1_x + 2*k2_x + 2*k3_x + k4_x)/6;
    double y_nuevo = *y + h*(k1_y + 2*k2_y + 2*k3_y + k4_y)/6;
    
    VALIDAR(x_nuevo); VALIDAR(y_nuevo);
    
    // Verificar conservacion de energia (x^2 + y^2 constante)
    double energia_antes = (*x)*(*x) + (*y)*(*y);
    double energia_despues = x_nuevo*x_nuevo + y_nuevo*y_nuevo;
    double delta_energia = fabs(energia_despues - energia_antes);
    
    if (delta_energia > 0.001 && iter_actual > 10) {
        printf("ADVERTENCIA [Iter %d]: Energia no se conserva\n", iter_actual);
        printf("   dE = %.2e, E_antes = %.6f, E_despues = %.6f\n", 
               delta_energia, energia_antes, energia_despues);
    }
    
    // Verificar si estamos en el circulo unitario (para condiciones iniciales tipicas)
    double radio = sqrt(x_nuevo*x_nuevo + y_nuevo*y_nuevo);
    if (fabs(radio - 1.0) > 0.1 && iter_actual > 5) {
        printf("ADVERTENCIA [Iter %d]: Radio diferente de 1\n", iter_actual);
        printf("   Radio = %.6f (deberia ser ~1)\n", radio);
    }
    
    *x = x_nuevo;
    *y = y_nuevo;
}

// ============================================================================
// PROGRAMA PRINCIPAL
// ============================================================================
int main() {
    // ============================================================================
    // VALIDACION INICIAL
    // ============================================================================
    printf("VALIDANDO SISTEMA DE ECUACIONES...\n");
    printf("-----------------------------------------------------------------\n");
    
    validar_parametros();
    
    double t = T_INICIAL;
    double x = X_INICIAL;
    double y = Y_INICIAL;
    int iter = 0;
    int iter_totales = (int)((T_FINAL - T_INICIAL) / PASO_H) + 1;
    
    double energia_inicial = X_INICIAL*X_INICIAL + Y_INICIAL*Y_INICIAL;
    
    printf("Sistema validado correctamente\n");
    printf("   Ecuaciones: dx/dt = y, dy/dt = -x\n");
    printf("   Condiciones: x(0) = %.1f, y(0) = %.1f\n", X_INICIAL, Y_INICIAL);
    printf("   Tiempo: [%.1f, %.1f]\n", T_INICIAL, T_FINAL);
    printf("   Paso: h = %.3f\n", PASO_H);
    printf("   Iteraciones estimadas: %d\n", iter_totales);
    printf("   Energia inicial: E = x^2 + y^2 = %.6f\n\n", energia_inicial);
    
    // ============================================================================
    // CONFIGURACION
    // ============================================================================
    printf("===============================================================\n");
    printf("          SISTEMA DE ECUACIONES: dx/dt=y, dy/dt=-x           \n");
    printf("===============================================================\n\n");
    
    FILE *datos_fase = abrir_archivo("sistema_fase.dat", "w");
    FILE *datos_x = abrir_archivo("sistema_x.dat", "w");
    FILE *datos_y = abrir_archivo("sistema_y.dat", "w");
    FILE *script_gp1 = abrir_archivo("sistema_temporal.gp", "w");
    FILE *script_gp2 = abrir_archivo("sistema_fase_plot.gp", "w");
    
    printf("PROCESO DE INTEGRACION:\n");
    printf("+------+--------+-----------+-----------+-----------+-----------+\n");
    printf("| Iter |   t    |   x(t)    |   y(t)    |  Energia  |  Estado   |\n");
    printf("+------+--------+-----------+-----------+-----------+-----------+\n");
    
    int errores_numericos = 0;
    double energia_max_desvio = 0.0;
    
    // ============================================================================
    // INTEGRACION DEL SISTEMA
    // ============================================================================
    while (t <= T_FINAL + PASO_H/2) {
        // Calcular energia actual
        double energia_actual = x*x + y*y;
        VALIDAR(energia_actual);
        
        double desvio_energia = fabs(energia_actual - energia_inicial);
        if (desvio_energia > energia_max_desvio) {
            energia_max_desvio = desvio_energia;
        }
        
        // Calcular soluciones exactas
        double x_exacto = cos(t);
        double y_exacto = -sin(t);
        
        // Estado de validacion
        const char *estado = "OK";
        if (!es_numerico_valido(x) || !es_numerico_valido(y)) {
            estado = "INVALIDO";
            errores_numericos++;
            
            printf("+------+--------+-----------+-----------+-----------+-----------+\n");
            printf("| %4d | %6.2f | %9.5f | %9.5f | %9.5f | %s |\n", 
                   iter, t, x, y, energia_actual, estado);
            printf("+------+--------+-----------+-----------+-----------+-----------+\n");
            
            printf("\nERROR CRITICO: Valores no numericos en iteracion %d\n", iter);
            printf("   t = %.6f, x = %.6f, y = %.6f\n", t, x, y);
            
            fclose(datos_fase);
            fclose(datos_x);
            fclose(datos_y);
            return EXIT_FAILURE;
        }
        
        // Mostrar cada 40 iteraciones
        if (iter % 40 == 0) {
            printf("| %4d | %6.2f | %9.5f | %9.5f | %9.5f | %s |\n", 
                   iter, t, x, y, energia_actual, estado);
        }
        
        // Guardar datos
        fprintf(datos_fase, "%.6f %.6f\n", x, y);
        fprintf(datos_x, "%.6f %.6f\n", t, x);
        fprintf(datos_y, "%.6f %.6f\n", t, y);
        
        // Ultimo punto
        if (t >= T_FINAL) break;
        
        // Calcular siguiente punto
        rk4_sistema2_validado(t, &x, &y, PASO_H, iter);
        
        t += PASO_H;
        iter++;
        
        // Verificar limite de iteraciones
        if (iter > iter_totales * 10) {
            printf("ADVERTENCIA: Demasiadas iteraciones (%d)\n", iter);
            break;
        }
    }
    
    printf("+------+--------+-----------+-----------+-----------+-----------+\n");
    printf("| INTEGRACION COMPLETADA: %d iteraciones                       |\n", iter);
    printf("+-------------------------------------------------------------+\n\n");
    
    fclose(datos_fase);
    fclose(datos_x);
    fclose(datos_y);
    
    // ============================================================================
    // CREAR SCRIPTS GNUPLOT
    // ============================================================================
    
    // Script 1: Evolucion temporal
    fprintf(script_gp1, "# Script para evolucion temporal\n");
    fprintf(script_gp1, "set terminal pngcairo size %d,%d enhanced font 'Arial,10'\n", 
            ANCHO_GRAFICO, ALTO_GRAFICO);
    fprintf(script_gp1, "set output '%s'\n", NOMBRE_GRAFICO1);
    fprintf(script_gp1, "set title 'Evolucion temporal: dx/dt = y, dy/dt = -x'\n");
    fprintf(script_gp1, "set xlabel 'Tiempo t'\n");
    fprintf(script_gp1, "set ylabel 'x(t), y(t)'\n");
    fprintf(script_gp1, "set grid\n");
    fprintf(script_gp1, "set key top right box\n");
    fprintf(script_gp1, "set xrange [%f:%f]\n", T_INICIAL, T_FINAL);
    
    fprintf(script_gp1, "plot 'sistema_x.dat' w l lw 2 lc rgb '#0066CC' title 'x(t)', \\\n");
    fprintf(script_gp1, "     'sistema_y.dat' w l lw 2 lc rgb '#FF3333' title 'y(t)', \\\n");
    fprintf(script_gp1, "     cos(x) w l lw 1 lc rgb '#0066CC' dt 2 title 'cos(t) (exacta)', \\\n");
    fprintf(script_gp1, "     -sin(x) w l lw 1 lc rgb '#FF3333' dt 2 title '-sin(t) (exacta)'\n");
    
    fclose(script_gp1);
    
    // Script 2: Plano de fase
    fprintf(script_gp2, "# Script para plano de fase\n");
    fprintf(script_gp2, "set terminal pngcairo size %d,%d enhanced font 'Arial,10'\n", 
            ANCHO_GRAFICO, ALTO_GRAFICO);
    fprintf(script_gp2, "set output '%s'\n", NOMBRE_GRAFICO2);
    fprintf(script_gp2, "set title 'Plano de fase: x vs y'\n");
    fprintf(script_gp2, "set xlabel 'x(t)'\n");
    fprintf(script_gp2, "set ylabel 'y(t)'\n");
    fprintf(script_gp2, "set grid\n");
    fprintf(script_gp2, "set key off\n");
    fprintf(script_gp2, "set size ratio -1\n");
    fprintf(script_gp2, "set xrange [-1.2:1.2]\n");
    fprintf(script_gp2, "set yrange [-1.2:1.2]\n");
    
    fprintf(script_gp2, "plot 'sistema_fase.dat' w l lw 1.5 lc rgb '#00AA00' title 'Trayectoria', \\\n");
    fprintf(script_gp2, "     cos(t), sin(t) w l lw 1 lc rgb '#000000' dt 2 title 'Circulo exacto'\n");
    
    fclose(script_gp2);
    
    // ============================================================================
    // EJECUTAR GNUPLOT
    // ============================================================================
    printf("GENERANDO GRAFICOS...\n");
    printf("-----------------------------------------------------------------\n");
    
    int resultado1 = system("gnuplot sistema_temporal.gp 2>&1");
    int resultado2 = system("gnuplot sistema_fase_plot.gp 2>&1");
    
    if (resultado1 != 0 || resultado2 != 0) {
        printf("ADVERTENCIA: Problemas al generar graficos\n");
        if (resultado1 != 0) {
            printf("   Error en grafico temporal\n");
        }
        if (resultado2 != 0) {
            printf("   Error en plano de fase\n");
        }
    } else {
        printf("Graficos generados correctamente:\n");
        printf("   • %s (evolucion temporal)\n", NOMBRE_GRAFICO1);
        printf("   • %s (plano de fase)\n", NOMBRE_GRAFICO2);
    }
    
    // ============================================================================
    // ANALISIS DE RESULTADOS
    // ============================================================================
    printf("\nANALISIS DE RESULTADOS:\n");
    printf("-----------------------------------------------------------------\n");
    
    double energia_final = x*x + y*y;
    double variacion_energia = fabs(energia_final - energia_inicial);
    double variacion_relativa = 100 * variacion_energia / energia_inicial;
    
    // Calcular errores respecto a solucion exacta
    double error_x_final = fabs(x - cos(T_FINAL));
    double error_y_final = fabs(y - (-sin(T_FINAL)));
    
    // Evaluar periodicidad
    double periodo_teorico = 2*M_PI;
    int ciclos_completos = (int)(T_FINAL / periodo_teorico);
    double fase_final = fmod(T_FINAL, periodo_teorico);
    
    printf("  Iteraciones:          %d\n", iter);
    printf("  Energia inicial:      %.8f\n", energia_inicial);
    printf("  Energia final:        %.8f\n", energia_final);
    printf("  Variacion energia:    %.2e (%.4f%%)\n", 
           variacion_energia, variacion_relativa);
    printf("  Error x final:        %.2e\n", error_x_final);
    printf("  Error y final:        %.2e\n", error_y_final);
    printf("  Ciclos completos:     %d\n", ciclos_completos);
    printf("  Fase final:           %.4f rad\n", fase_final);
    printf("  Errores numericos:    %d\n", errores_numericos);
    
    // Evaluar conservacion de energia
    printf("\n  EVALUACION DE CONSERVACION:\n");
    if (variacion_relativa < 0.01) {
        printf("    Excelente conservacion (dE < 0.01%%)\n");
    } else if (variacion_relativa < 0.1) {
        printf("    Buena conservacion (dE < 0.1%%)\n");
    } else if (variacion_relativa < 1.0) {
        printf("    Conservacion aceptable (dE < 1%%)\n");
    } else {
        printf("    Mala conservacion, metodo puede ser inestable\n");
        printf("       Considere reducir el paso h\n");
    }
    
    // Evaluar precision de solucion
    printf("\n  EVALUACION DE PRECISION:\n");
    double error_maximo = fmax(error_x_final, error_y_final);
    if (error_maximo < 0.001) {
        printf("    Excelente precision (error < 0.001)\n");
    } else if (error_maximo < 0.01) {
        printf("    Buena precision (error < 0.01)\n");
    } else if (error_maximo < 0.1) {
        printf("    Precision aceptable (error < 0.1)\n");
    } else {
        printf("    Precision pobre\n");
    }
    
    // ============================================================================
    // VALIDACION DE PROPIEDADES DEL SISTEMA
    // ============================================================================
    printf("\nVALIDACION DE PROPIEDADES DEL SISTEMA:\n");
    printf("-----------------------------------------------------------------\n");
    
    // Verificar que satisface las ecuaciones
    double dx_dt = F1(x, y);
    double dy_dt = F2(x, y);
    
    printf("  En t = %.4f:\n", t);
    printf("    x calculado:       %.8f\n", x);
    printf("    y calculado:       %.8f\n", y);
    printf("    dx/dt calculado:   %.8f\n", dx_dt);
    printf("    dy/dt calculado:   %.8f\n", dy_dt);
    printf("    dx/dt teorico:     y = %.8f\n", y);
    printf("    dy/dt teorico:     -x = %.8f\n", -x);
    
    // Verificar ortogonalidad (x·dx/dt + y·dy/dt = 0 para energia constante)
    double producto = x*dx_dt + y*dy_dt;
    printf("    x·dx/dt + y·dy/dt: %.2e (deberia ser ~0)\n", producto);
    
    if (fabs(producto) > 0.01) {
        printf("  ADVERTENCIA: Producto escalar grande\n");
        printf("     Indica posible error en la solucion\n");
    }
    
    // ============================================================================
    // RESUMEN FINAL
    // ============================================================================
    printf("\nRESUMEN DE EJECUCION:\n");
    printf("-----------------------------------------------------------------\n");
    printf("  Estado:              %s\n", 
           (errores_numericos == 0) ? "EXITOSO" : "CON ADVERTENCIAS");
    printf("  Iteraciones:         %d\n", iter);
    printf("  dEnergia:            %.2e (%.4f%%)\n", 
           variacion_energia, variacion_relativa);
    printf("  Error maximo:        %.2e\n", error_maximo);
    printf("  Graficos generados:  %s\n", 
           (resultado1 == 0 && resultado2 == 0) ? "2/2" : "PARCIAL");
    printf("  Archivos creados:    6 archivos de datos y scripts\n");
    
    printf("\n===============================================================\n");
    printf("                      EJECUCION COMPLETADA                     \n");
    printf("===============================================================\n");
    
    return (errores_numericos == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
}
\end{lstlisting}

\subsection{Gr\'aficos generados por el Programa 7}

La Figura 13 muestra la evoluci\'on temporal de las variables x(t) y y(t) en el espacio de fases.
\begin{center}
  \includegraphics[height=7cm]{sistema_edo1}\\
  Figura 13: Trayectorias en el espacio de fases.
\end{center}

\subsection{An\'alisis de resultados}
La Figura 13 presenta las trayectorias acopladas del sistema, mostrando las interacciones entre las variables.

\subsection{Verificaci\'on}
\begin{center}
  \includegraphics[height=7cm]{sistema_edo2}\\
  Figura 14: Conservaci\'on de cantidades del sistema.
\end{center}

\section{Conclusiones}

Los 7 programas implementan m\'etodos num\'ericos fundamentales para la soluci\'on de problemas matem\'aticos complejos. Desde la b\'usqueda de ra\'ices hasta la soluci\'on de sistemas de ecuaciones diferenciales, cada algoritmo muestra su eficiencia y precisi\'on en su dominio de aplicaci\'on. El uso de m\'etodos como Newton-Raphson, series de Fourier y Runge-Kutta proporciona herramientas poderosas para el an\'alisis num\'erico en diversas \'areas de la ingenier\'ia y ciencias.

\begin{flushright}
{\bf Fin del Reporte}
\end{flushright}

\end{document}